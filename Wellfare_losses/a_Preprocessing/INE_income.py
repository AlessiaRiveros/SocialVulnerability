##
import pandas as pd
import os
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from optimize_reco import optimize_reco

pdir = r'p:\11209200-020-sociale-kwetsbaarheid'

pd.set_option('display.max_columns', None)

# ----------------- configurations -----------------
# productivity = output-side real GDP / capital stock from PWT
# prod = cgdpo / cn
prod = 83541 / 170129

# fraction affected by return period from FIAT output
f2 = 0.016
f10 = 0.039

# elasticity of the marginal utility of consumption
# 1.5 in line with Hallegatte et al 2016 and Walsh and Hallegatte 2019
elast = 1.5

# discount rate from J. A. Rueda-Gallardo 2020 (find one corresponding to 2016)
disc = 12.67 / 100

# subsistence line from INE per person per month in Bs
# convert to years as reconstruction is measured in years
poverty = 804.8 * 12
extreme_poverty = 395.3 * 12

# ----------------- load data -----------------
df = pd.read_spss(os.path.join(pdir, 'Data', 'INE', 'Bases_EPF_2015-2016', 'EPF1516_Persona Ingreso.sav'))
df_home = pd.read_csv(os.path.join(pdir, 'Data', 'INE', 'processed', 'EPF1516_Vivienda_processed.csv'))


# ----------------- process data -----------------
# filter to area of interest dept = Santa Cruz and urban
df = df.loc[(df['area'] == 'Urbana') & (df['dept'] == '07 Santa Cruz')]

# for testing keep only 50 rows
# df = df.iloc[:20]

# convert folio to int
df['folio'] = df['folio'].astype('int64')
# seccion4: ingresos laborales
# seccion5: ingresos no laborales

variable = {
    's4_17a': 'Liquid Salary (Amount)',
    's4_17b': 'Liquid Salary (Frequency)',
    's4_18a': 'Bonus (Amount) Received',
    's4_18b': 'Christmas Bonus (Amount)',
    's4_22a1': 'Total Income in Primary Occupation (Amount)',
    's4_22a2': 'Total Income in Primary Occupation (Frequency)',
    'ysal1net': 'Salary',
    'ysal1ben_1': 'Bonus',
    'ysal1ben_2': 'Christmas bonus',
    'ysal1ben': 'Total benefits from salaried employment - 1st employment',
    'ysal2ben': 'Total benefits from salaried employment - 2nd employment',
    'ym_especie': 'Total labor income',
    'y_monetario': 'Total labor and non-labor income', # income ih
    # Sumatoria total de ingresos monetarios e ingresos no mometarios, mensualizado, por hogar?
    'ym_transferencia_gob': 'Total transfers from Gov',
    'ym_transferencia_hog': 'Transferencias entre hogares por remesas o internas',
    'ym_transferencia_tot': 'Total transfers from gov, soc security or from other hh'
}

# replace NaN in i labor and i h (labor and non labor) and social transfer
df['y_monetario'] = df['y_monetario'].fillna(0)
df['ym_especie'] = df['ym_especie'].fillna(0)
df['ym_transferencia_gob'] = df['ym_transferencia_gob'].fillna(0)
df['ym_transferencia_hog'] = df['ym_transferencia_hog'].fillna(0)
df['ym_transferencia_ss'] = df['ym_transferencia_ss'].fillna(0)

# groupy by hh to perform all calculations per hh
df['pop'] = 1  # to know how many people per household
num_cols = df.select_dtypes(include='number').columns
df = df[num_cols].fillna(0)
df = df.groupby('folio').sum()

# print some statistics about labor income
print(f'Min: {df.ym_especie.min()}')
print(f'Max: {df.ym_especie.max()}')
print(f'Mean: {df.ym_especie.mean()}')
print(f'Median: {df.ym_especie.median()}')

# Csp gov spending on social protection
# transfers received from friends and family added to social transfers
df['isp'] = df['ym_transferencia_gob'] + df['ym_transferencia_hog'] + df['ym_transferencia_ss']
Csp = df['isp'].sum()

# flat income tax that finances social programs
tax = Csp / df['y_monetario'].sum()
print(f'tax: {tax}')

# effective capital stock
df['keff'] = (df['y_monetario'] - df['ym_especie']) / (1-tax) / prod

# merge on folio dwelling table with income to include vulnerability
df = pd.merge(df, df_home, left_on='folio', right_on='folio')

# change in keff
df['dkeff'] = df['keff'] * df['v']

# total exposed assets K
K = (df['dkeff']).sum()

# total asset losses L
L10 = K * f10
L2 = K * f2

# change in social transfers
df['disp10'] = L10/K * df['isp']
df['disp2'] = L2/K * df['isp']

# income losses
df['dih10'] = (1-tax) * prod * df['dkeff'] + df['disp10']
df['dih2'] = (1-tax) * prod * df['dkeff'] + df['disp2']

# asset reconstruction
# optimal recovery rate
df['reco_rate'] = df.apply(optimize_reco, axis=1)

# recovery time in years
df['reco_time'] = np.log(1/0.05) / df['reco_rate']

# example for a single hh dkeff non nan
index = df['keff'].idxmax()

# save dataframe
print(df.head(2))
df[['folio', 'pop', 'y_monetario', 'ym_especie', 'keff', 'v', 'estrato', 'dkeff', 'disp10', 'disp2', 'dih10', 'dih2',
    'reco_rate', 'reco_time']]\
    .to_csv(os.path.join(pdir, 'Data', 'INE', 'processed', 'EPF1516_Persona Ingreso_processed.csv'))

# # ----------------- plotting -----------------

# ih and dih
fig, ax = plt.subplots(1, figsize=(7, 5))
sns.histplot(data=df[['ym_especie']])
# sns.histplot(data=df_hh, x='y_monetario', label='$i_h$')
ax.set_xlim(left=0)
ax.set_xlabel('Monthly hh income [Bs]')
ax.set_yscale('log')
plt.savefig(os.path.join(pdir, 'Figures', 'INE', 'hh_labor_income_logscale.png'))

fig, ax = plt.subplots()
sns.histplot(data=df, x='reco_time', ax=ax)
ax.set_xlabel('Recovery time [years]')
plt.savefig(os.path.join(pdir, 'Figures', 'INE', 'processed', 'recovery_time.png'))

plt.show()