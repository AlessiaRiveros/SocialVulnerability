import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
from shapely.geometry import box
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np

pdir = r'p:\11209200-020-sociale-kwetsbaarheid'

# ----------------- configurations -----------------
T = 10
# how to aggregate max damages, total = sum, average per building = mean
method = 'total'  # "total" or "average"
building_type = "residential"
# consider the whole extent or only the inner ring
extent = 'full_extent'  # "full_extent" or "inner_ring"
# boundary for the income classes "high" "med" or "low
boundary_type = 'low'

# ----------------- load data -----------------
df = pd.read_csv(os.path.join(pdir, 'Data', 'FIAT', 'EW', f'AZONE_T{T}_{building_type}_{method}_{boundary_type}.csv'),
                 usecols=['IDazone', 'inner_ring', 'TD_E', 'EW_TD_E'])
gdf = gpd.read_file(os.path.join(pdir, 'Data', 'Income', 'AZONE.shp'))

# ----------------- process data -----------------

# df.index = df['IDazone']
# df = df.drop(columns='IDazone')
# boundaries to exclude areas where FIAT results not available
xmin = -63.26
xmax = -63.05
ymin = -17.9
ymax = -17.65

bbox = box(xmin, ymin, xmax, ymax)
gdf = gpd.clip(gdf, mask=bbox)

# extent
fs = 6
if extent == "inner_ring":
    df = df[df['inner_ring'] == 'Yes']
    fs = 10

df = df.dropna(subset=['TD_E', 'EW_TD_E'])
df['rank_TD_E'] = df['TD_E'].rank(ascending=False).astype(int)
df['rank_EW_TD_E'] = df['EW_TD_E'].rank(ascending=False).astype(int)
df = df.rename(columns={"IDazone": "ID"})

gdf = gdf.merge(df, on='ID')
gdf_TD_E = gdf[(gdf['rank_TD_E']) <= 10]
gdf_EW_TD_E = gdf[(gdf['rank_EW_TD_E']) <= 10]

print(gdf_TD_E)

# format the dataframe for the heatmap
# keep only first 10 of both
df = df[(df['rank_TD_E'] <= 10) | (df['rank_EW_TD_E'] <= 10)]
# set ID as index
df = df.set_index('ID')

# ----------------- plotting -----------------

# plot rank heatmaps from traditional damage and EW damage
fig, ax = plt.subplots(1, figsize=(5, 8))
sns.heatmap(df[['rank_TD_E', 'rank_EW_TD_E']], ax=ax, annot=True)
ax.set_title(f'{method} {building_type} damages')
plt.savefig(os.path.join(pdir, 'Figures', 'Residential', f'T{T}', f'T{T}_{building_type}_{method}_{extent}_heatmap_ranking.png'))

# plot location on map of these areas
fig, ax = plt.subplots(1, 2, figsize=(10, 6))

ax0_divider = make_axes_locatable(ax[0])
ax1_divider = make_axes_locatable(ax[1])

cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")

gdf.boundary.plot(ax=ax[0], color='black', lw=0.8)
ax[0].set_axis_off()
gdf_TD_E.plot(column='rank_TD_E', ax=ax[0], cax=cax0, cmap='rocket', legend=True)

gdf.boundary.plot(ax=ax[1], color='black', lw=0.8)
ax[1].set_axis_off()
gdf_EW_TD_E.plot(column='rank_EW_TD_E', ax=ax[1], cax=cax1, cmap='rocket', legend=True)

# add labels
for x, y, label in zip(gdf_TD_E.geometry.representative_point().x, gdf_TD_E.geometry.representative_point().y,
                       gdf_TD_E['ID']):
    ax[0].text(x, y, label, fontsize=fs, ha='right', va='bottom', color='grey', fontweight='bold')

for x, y, label in zip(gdf_EW_TD_E.geometry.representative_point().x, gdf_EW_TD_E.geometry.representative_point().y,
                       gdf_EW_TD_E['ID']):
    ax[1].text(x, y, label, fontsize=fs, ha='right', va='bottom', color='grey', fontweight='bold')

ax[0].title.set_text(f'Top 10 TD {method} Residential Damages')
ax[1].title.set_text(f'Top 10 EW {method} Residential Damages')
plt.tight_layout()
plt.savefig(os.path.join(pdir, 'Figures', 'Residential', f'T{T}', f'T{T}_{building_type}_{method}_{extent}_ranking.png'))

plt.show()