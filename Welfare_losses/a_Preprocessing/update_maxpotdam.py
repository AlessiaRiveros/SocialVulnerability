import geopandas as gpd
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
from sklearn import preprocessing

pdir = r'p:\11209200-020-sociale-kwetsbaarheid'
csv_out = pdir + "/data_cleaned/Income/b_intermediate/income_dwelling.csv"
exposure_out = pdir + "/data_cleaned/FIAT/b_intermediate/exposure.csv"

obj_shp = pdir + "/FIAT/2023_04_05_santa_cruz_run_20cm_groundfloorheight/Database/Exposure/santaCruz/clipped_ids.shp"
obj_gdf = gpd.read_file(obj_shp)

exposure_csv = pdir + "/FIAT/FIAT_database/Exposure/santaCruz/exposure.csv"
exposure_df = pd.read_csv(exposure_csv)

# azone
azone_shp = pdir + "/data_cleaned/Income/a_raw/AZONE.shp"
azone_gdf = gpd.read_file(azone_shp)

# ingresos
ingresos_csv = pdir + "/data_cleaned/EW/10_database.csv"
ingresos_df = pd.read_csv(ingresos_csv)

# valor de vivienda por tipologia en Santa Cruz
tipo_vivienda = ["De Lujo", "Muy Buena", "Buena", "Economica", "Interes Social", "Marginal"]
valor_vivienda = [3423, 2283, 1516, 950, 570, 96]
vivienda_df = pd.DataFrame({"Tipo de vivienda": tipo_vivienda, "Valor de la vivienda [Bs/m2]": valor_vivienda})


def normalize(x, xmin, xmax):
    return (x - xmin) / (xmax - xmin)


# normalizar vivienda
vivienda_df["Valor normalizado"] = vivienda_df.apply(
    lambda row: normalize(row["Valor de la vivienda [Bs/m2]"],
                          vivienda_df["Valor de la vivienda [Bs/m2]"].min(),
                          vivienda_df["Valor de la vivienda [Bs/m2]"].max()),
    axis=1)


# normalizar ingresos
ingresos_df["I_cap_year_norm"] = ingresos_df.apply(
    lambda row: normalize(row["I_cap_year"],
                          ingresos_df["I_cap_year"].min(),
                          ingresos_df["I_cap_year"].max()),
    axis=1)

ingresos_df.sort_values(by="I_cap_year_norm", ascending=False, inplace=True)
# drop nan values
ingresos_df.dropna(subset="I_cap_year_norm", inplace=True)

ingresos_df["dwelling"] = np.nan
# find closest value in normalized income to normalized dwelling
for dwelling_id in np.arange(0, 6):
    idx = ingresos_df.iloc[(ingresos_df["I_cap_year_norm"] - vivienda_df.loc[dwelling_id, "Valor normalizado"]).abs().argsort()[:1]].index.item()
    ingresos_df.loc[idx, "dwelling"] = vivienda_df.loc[dwelling_id, "Valor de la vivienda [Bs/m2]"]

# interpolate for the rest of the values
ingresos_df.set_index("I_cap_year_norm", inplace=True)
ingresos_df["dwelling"] = ingresos_df["dwelling"].interpolate(method="linear", limit_direction="both")
ingresos_df.reset_index(inplace=True)

# incluir depreciacion y 1 - proteccion
ingresos_df["act_dwelling"] = ingresos_df["dwelling"] * 0.6 * (1-0.4) * 1

# save df
ingresos_df = ingresos_df[["IDazone", "I_cap_year_norm", "I_cap_year", "dwelling", "act_dwelling"]]
ingresos_df.to_csv(csv_out)

# add dwelling values to AZONE gpd based on the ID = IDazone
azone_gdf = azone_gdf.rename(columns={"ID": "IDazone"})
azone_gdf = azone_gdf.merge(ingresos_df, on="IDazone")

# get area of objects
obj_gdf["area"] = obj_gdf.area

# object and azone crs are not the same
azone_gdf = azone_gdf.to_crs("EPSG:32720")
# find objects corresponding to azone
gdf = obj_gdf.sjoin(azone_gdf, predicate="within")

# for each object id use the dwelling value x area
gdf["maxpotdam"] = gdf["area"] * gdf["act_dwelling"]

# include contents JRC max str dam * 0.5 for residential buildings
gdf["content"] = gdf["maxpotdam"] * 0.5

# rename columns to match what FIAT expects
gdf = gdf.rename(columns={
    "OBJECTID": "Object ID",
    "maxpotdam": "Max Potential Damage: Structure",
    "content": "Max Potential Damage: Content"
})
gdf = gdf[["Object ID", "Max Potential Damage: Structure", "Max Potential Damage: Content"]]
# keep original column order
cols = exposure_df.columns
# drop columns to replace
exposure_df = exposure_df.drop(columns=["Max Potential Damage: Structure", "Max Potential Damage: Content"])

df = exposure_df.merge(gdf, on="Object ID")
df = df[cols]
df.to_csv(exposure_out, index=False)
