import pandas as pd
import numpy as np
import math
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.wkt import loads
from shapely.geometry import box
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.ticker as ticker
from functions import *

n = 1.5
p = 0.1

data_ = pd.read_csv(r"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\data\census_data_incl.csv")

data_copy = data_.copy()
data_copy['geometry'] = data_copy['geometry'].apply(loads)
data_shape = gpd.GeoDataFrame(data_copy, geometry="geometry", crs='EPSG:4326')
data = data_shape

# some metadata would be useful to understand what all the variables really mean...
data['ave_i_0'] = (data['i_0_owner']/data['owner_households'])
# data['ave_i_0'] = np.where(data['A'].isnull(), np.nan, data['ave_i_0'])
# I wouldn't divide the next two lines by fraction but the value of v doesn't change
data['ave_k_str'] = (data['Max Potential Damage: Structure']/data['#_households']) * data['fraction']
data['ave_damage'] = (data['Damage: Structure']/data['#_households']) * data['fraction']
data['k_str_v2'] = (data['Max Potential Damage: Structure']/data['#_households'])
data['ave_damage_v2'] = (data['Damage: Structure']/data['#_households'])
data['total_damage'] = data['Damage: Structure'] * data['fraction']
# assumption c0=i0
data['ave_c_0'] = data['ave_i_0']
data['v'] = data['ave_damage'] / data['ave_k_str']

xmin = -80.05
xmax = -79.85
ymin = 32.6
ymax = 32.8

bbox = box(xmin, ymin, xmax, ymax)
data = gpd.clip(data, mask=bbox)
# let's plot the v spatially and the income as well
# nan values!
data["ave_i_0_M"] = data["ave_i_0"]/1e6
fig, ax = plt.subplots()
# data.geometry.plot(ax=ax)
ax_divider = make_axes_locatable(ax)
cax = ax_divider.append_axes("right", size="5%", pad="1%")
data.plot(
    column="ave_i_0_M",
    ax=ax,
    cax=cax,
    cmap="OrRd",
    vmax=2,
    edgecolor="k",
    legend=True,
    legend_kwds={
        "label": "Million (US$)"
    },
    missing_kwds={
        "color": "lightgrey",
        "label": "Missing values"
    }
)
data.loc[[0, 42]].boundary.plot(ax=ax, edgecolor='blue', facecolor="none")
ax.set_axis_off()
plt.tight_layout()
plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\average_predisaster_income_owner_hh.png")


#
# # for idx, row in data.iterrows():
# #     centroid = row.geometry.centroid
# #     ax.annotate(text=str(idx), xy=(centroid.x, centroid.y), color='k', fontsize=5)
#
fig, ax = plt.subplots()
# data.geometry.plot(ax=ax)
ax_divider = make_axes_locatable(ax)
cax = ax_divider.append_axes("right", size="5%", pad="1%")
data.plot(
    column="v",
    ax=ax,
    cax=cax,
    cmap="OrRd",
    edgecolor="k",
    legend=True,
    legend_kwds={
        "label": "vulnerability (-)"
    },
    missing_kwds={
        "color": "lightgrey",
        "label": "Missing values"
    }
)
data.loc[[0, 42]].boundary.plot(ax=ax, edgecolor='blue', facecolor="none")
ax.set_axis_off()
plt.tight_layout()
plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\average_vulnerability.png")

plt.show()
# for idx, row in data.iterrows():
#     centroid = row.geometry.centroid
#     ax.annotate(text=str(idx), xy=(centroid.x, centroid.y), color='k', fontsize=5)

# take two rows
# data = data.loc[[0, 42]]
index=42
data = data.loc[index]

# recovery rate
v = data['v']
ave_k_str = data['ave_k_str']
ave_i_0 = data['ave_i_0']
ave_c_0 = data['ave_c_0']
ave_damage = data["ave_damage"]
k_str_v2 = data['k_str_v2']
ave_damage_v2 = data['ave_damage_v2']

labda = optimal_labda(v, ave_k_str, ave_i_0, ave_c_0)
reco_time = np.log(1/0.05)/labda

print(f"kstr: {ave_k_str:.0f}\ndelta_kstr: {ave_damage:.0f}\naverage income: {ave_i_0:.0f}"
      f"\nvulnerability: {v:.2f}\nlambda: {labda:.1f}\nrecovery time: {reco_time:.1f}")
print(f"version2 kstr: {k_str_v2:.0f} and delta_kstr: {ave_damage_v2:.0f}")

c = []
u = []
c_reconstruction = []
i = []

times = np.linspace(0, 2, 50, endpoint=True) # why do we start at -2? negative time? does it make sense?

for year in times:

    consumption = ave_c_0
    v = v
    k_str = ave_k_str
    labda = labda
    i_wage = ave_i_0

    results_c_t = c_t(year, labda, v, k_str, i_wage, consumption)
    results_u_t = u_t(year, labda, v, k_str, i_wage, consumption)
    results_c_reco = c_reco(year, labda, v, k_str)
    results_i = delta_i(year, labda, v, i_wage)

    c.append(results_c_t)
    u.append(results_u_t)
    c_reconstruction.append(results_c_reco)
    i.append(results_i)

# welfare
consumption = ave_c_0
k_str = ave_k_str
labda = labda
i_wage = ave_i_0

delta_c = total_delta_c(labda, v, k_str, i_wage)
delta_i = total_delta_i(labda, v, i_wage)
W = delta_W(labda, v, k_str, i_wage, consumption)

print(f'welfare: {W:.6f}\nconsumption loss: {delta_c:.0f}\nincome loss: {delta_i:.0f}')

# consumption equivalent
c_mean_total = 364004.28087966004
cons_eq = W/c_mean_total**(-n)

print(f'equivalent consumption change: {cons_eq:.0f}')

# create a DataFrame
df = pd.DataFrame({
    "index": index,
    "delta_kstr": ave_damage,
    "delta_i": delta_i,
    "delta_W": cons_eq
}, index=range(1))
df.to_csv(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\data\{index}_variables.csv")

##  plot household consumption change
def format_func(value, _):
    # Convert the value into a formatted string with spacing
    return "{:,.0f}".format(value)


xmin = -0.5
fs = 10
ymax = ave_c_0
fig, ax = plt.subplots()

# consumption
ax.plot(times, c, color="b", label="c(t)", ls="--", lw=1.2, zorder=9)
print(c[0], ave_c_0)
kwargs = {"color": "b", "linestyle": "--", "linewidth": 1.2}
ax.vlines(x=0, ymin=c[0], ymax=ave_c_0, **kwargs)
ax.hlines(y=ave_c_0, xmin=xmin, xmax=0, **kwargs)
# add c0
ax.text(xmin*1.05, ave_c_0, "c$_0$", fontsize=fs, ha="right", va="center", color="k", zorder=10)

# # reconstruction cost?
# ax.plot(times, ave_c_0 - i- c_reconstruction, color="green", label="c_reco(t)", zorder=2)

# change in income
ax.plot(times, ave_c_0 - i, color="purple", alpha=0.8, lw=1, label=r"$\Delta$i", zorder=2)
kwargs = {"color": "purple", "linestyle": "-", "linewidth": 1, "alpha": 0.8}
ax.vlines(x=0, ymin=ave_c_0 - i[0], ymax=ave_c_0, **kwargs)

# recovery rate
ax.plot([], [], " ", label=rf"$\lambda$ = {labda:.1f}")

# recovery time
ax.axvline(x=reco_time, color="r", alpha=0.9, lw=0.6)
ax.text(reco_time, ymax*1.03, rf"$\tau$ = {reco_time:.2f}", fontsize=fs, ha="center", va="bottom", color="r", zorder=10)

# formatting
ax.yaxis.set_major_formatter(ticker.FuncFormatter(format_func))
ax.set_xlim(xmin, 2)
ax.set_ylabel('Household consumption, c(t)')
ax.set_xlabel('Time t after disaster (yrs)')
ax.legend(loc="lower right")
plt.tight_layout()

plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\{index}_postdisaster_consumption.png")
plt.show()

