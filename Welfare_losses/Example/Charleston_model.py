import pandas as pd
import numpy as np
import math
import geopandas as gpd
import matplotlib.pyplot as plt
from shapely.wkt import loads
from shapely.geometry import box
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.ticker as ticker
from Welfare_losses.Example.functions import *
from Welfare_losses.Example.plot_functions import plot_hh_consumption

n = 1.5
p = 0.1

data_ = pd.read_csv(r"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\data\census_data_incl.csv")

data_copy = data_.copy()
data_copy['geometry'] = data_copy['geometry'].apply(loads)
data_shape = gpd.GeoDataFrame(data_copy, geometry="geometry", crs='EPSG:4326')
data = data_shape

# some metadata would be useful to understand what all the variables really mean...
data['ave_i_0'] = (data['i_0_owner']/data['owner_households'])
# data['ave_i_0'] = np.where(data['A'].isnull(), np.nan, data['ave_i_0'])
# I wouldn't divide the next two lines by fraction but the value of v doesn't change
data['ave_k_str'] = (data['Max Potential Damage: Structure']/data['#_households']) * data['fraction']
data['ave_damage'] = (data['Damage: Structure']/data['#_households']) * data['fraction']
data['k_str_v2'] = (data['Max Potential Damage: Structure']/data['#_households'])
data['ave_damage_v2'] = (data['Damage: Structure']/data['#_households'])
data['total_damage'] = data['Damage: Structure'] * data['fraction']
# assumption c0=i0
data['ave_c_0'] = data['ave_i_0']
data['v'] = data['ave_damage'] / data['ave_k_str']

##
# xmin = -80.05
# xmax = -79.85
# ymin = 32.6
# ymax = 32.8
#
# bbox = box(xmin, ymin, xmax, ymax)
# data = gpd.clip(data, mask=bbox)
# # let's plot the v spatially and the income as well
# # nan values!
# data["ave_i_0_M"] = data["ave_i_0"]/1e6
# fig, ax = plt.subplots()
# # data.geometry.plot(ax=ax)
# ax_divider = make_axes_locatable(ax)
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# data.plot(
#     column="ave_i_0_M",
#     ax=ax,
#     cax=cax,
#     cmap="OrRd",
#     vmax=2,
#     edgecolor="k",
#     legend=True,
#     legend_kwds={
#         "label": "Million (US$)"
#     },
#     missing_kwds={
#         "color": "lightgrey",
#         "label": "Missing values"
#     }
# )
# data.loc[[0, 42]].boundary.plot(ax=ax, edgecolor='blue', facecolor="none")
# ax.set_axis_off()
# plt.tight_layout()
# plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\average_predisaster_income_owner_hh.png")
#
#
# #
# # # for idx, row in data.iterrows():
# # #     centroid = row.geometry.centroid
# # #     ax.annotate(text=str(idx), xy=(centroid.x, centroid.y), color='k', fontsize=5)
# #
# fig, ax = plt.subplots()
# # data.geometry.plot(ax=ax)
# ax_divider = make_axes_locatable(ax)
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# data.plot(
#     column="v",
#     ax=ax,
#     cax=cax,
#     cmap="OrRd",
#     edgecolor="k",
#     legend=True,
#     legend_kwds={
#         "label": "vulnerability (-)"
#     },
#     missing_kwds={
#         "color": "lightgrey",
#         "label": "Missing values"
#     }
# )
# data.loc[[0, 42]].boundary.plot(ax=ax, edgecolor='blue', facecolor="none")
# ax.set_axis_off()
# plt.tight_layout()
# plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\average_vulnerability.png")

##

# for idx, row in data.iterrows():
#     centroid = row.geometry.centroid
#     ax.annotate(text=str(idx), xy=(centroid.x, centroid.y), color='k', fontsize=5)

# take two rows
# data = data.loc[[0, 42]]
index=42
data = data.loc[index]

# recovery rate
v = data['v']
ave_k_str = data['ave_k_str']
ave_i_0 = data['ave_i_0']
ave_c_0 = data['ave_c_0']
ave_damage = data["ave_damage"]
k_str_v2 = data['k_str_v2']
ave_damage_v2 = data['ave_damage_v2']

opt_labda = optimal_labda(v, ave_k_str, ave_i_0, ave_c_0)
opt_obj_fun = objective_function(opt_labda, v, ave_k_str, ave_i_0, ave_c_0)

print(f"kstr: {ave_k_str:.0f}\ndelta_kstr: {ave_damage:.0f}\naverage income: {ave_i_0:.0f}"
      f"\nvulnerability: {v:.2f}\nlambda: {opt_labda:.1f}")
print(f"version2 kstr: {k_str_v2:.0f} and delta_kstr: {ave_damage_v2:.0f}")


startyr = 0
endyr = 2
times = np.linspace(startyr, endyr, 100, endpoint=True)

i_wage = ave_i_0
consumption = ave_c_0
v = v
k_str = ave_k_str

fig, ax = plt.subplots()
for labda in [1, 3, 5]:
    c = []
    u = []
    c_reconstruction = []
    i = []
    for year in times:

        results_c_t = c_t(year, labda, v, k_str, i_wage, consumption)
        results_u_t = u_t(year, labda, v, k_str, i_wage, consumption)
        results_c_reco = c_reco(year, labda, v, k_str)
        results_i = delta_i(year, labda, v, i_wage)

        c.append(results_c_t)
        u.append(results_u_t)
        c_reconstruction.append(results_c_reco)
        i.append(results_i)

    obj_fun = objective_function(labda, v, k_str, i_wage, ave_c_0)

    ax.plot(times, np.array(u) * -1, label=f"$\lambda$: {labda} obj function: {obj_fun:.5f}")
    ax.set_xlabel('Time t after disaster (yrs)')

ax.set_title(f'optimal $\lambda$ is {opt_labda:.2f}, obj function is {opt_obj_fun:.5f}')
ax.set_xlim(startyr, endyr)
ax.set_ylabel("-u(t)")
# ax.axes.set_xscale("log")
ax.legend()
plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\{index}_utility.png")
plt.show()
# # welfare
# consumption = ave_c_0
# k_str = ave_k_str
# labda = labda
# i_wage = ave_i_0
#
# delta_c = total_delta_c(labda, v, k_str, i_wage)
# delta_i = total_delta_i(labda, v, i_wage)
# W = delta_W(labda, v, k_str, i_wage, consumption)
#
# print(f'welfare: {W:.6f}\nconsumption loss: {delta_c:.0f}\nincome loss: {delta_i:.0f}')
#
# # consumption equivalent
# c_mean_total = 364004.28087966004
# cons_eq = W/c_mean_total**(-n)
#
# print(f'equivalent consumption change: {cons_eq:.0f}')
#
# # create a DataFrame
# df = pd.DataFrame({
#     "index": index,
#     "delta_kstr": ave_damage,
#     "delta_i": delta_i,
#     "delta_W": cons_eq
# }, index=range(1))
# df.to_csv(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\data\{index}_variables.csv")

## plot utility and objective function for different lambda values?
lambdas = np.linspace(0.01, 5, 50)
obj_funs = []
for l in lambdas:
    value = objective_function(l, v, k_str, i_wage, ave_c_0)
    obj_funs.append(value)

obj_funs = np.array(obj_funs)
fig, ax = plt.subplots()
ax.plot(lambdas, obj_funs)
ax.axvline(opt_labda, ls="--")
ax.set_ylabel("-âˆ«u(t)dt")
ax.set_xlabel("$\lambda$")
plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\{index}_obj_fun.png")
plt.show()


##  plot household consumption change

fig, ax = plt.subplots()
ax = plot_hh_consumption(ax, times, ave_c_0, c, c_reconstruction, i, labda)
plt.tight_layout()

plt.savefig(rf"p:\11209200-020-sociale-kwetsbaarheid\Wellbeing_Charleston\figures\{index}_postdisaster_consumption.png")
plt.show()

