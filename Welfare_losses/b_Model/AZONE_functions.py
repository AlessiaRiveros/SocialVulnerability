import math
import numpy as np
import tomli
from scipy.integrate import quad
from scipy.optimize import minimize

with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)

pi = config['pi']
rho = config['rho']
eta = config['eta']
gdp = config['gdp']

extreme_poverty = config['extremepoverty'] * 12


def inc_loss(t, l, v, inc):
    return v * inc * math.e ** (-t * l)


def reco_costs(t, l, d_kprv):
    return d_kprv * l * math.e ** (-t * l)


c_negative = []


def c_t(t, l, v, inc, d_kprv):
    delta_income = inc_loss(t, l, v, inc)
    c_recovery = reco_costs(t, l, d_kprv)

    c = inc - (c_recovery + delta_income)

    if np.all(t < np.array([0])):
        return inc
    elif np.all(c < np.array([0])):
        c_negative.append(c)
        return c
    else:
        return c


def cons_loss(t, l, v, inc, d_kprv):
    d_inc = inc_loss(t, l, v, inc)
    c_reco = reco_costs(t, l, d_kprv)
    return d_inc + c_reco


def utility(t, l, v, inc, d_kprv):
    consumption = c_t(t, l, v, inc, d_kprv)
    return (consumption ** (1 - eta)) / (1 - eta)


def obj_function(l, v, inc, d_kprv):
    # integral_value, _ = quad(utility, 0, 10, args=(v, inc, d_kprv, l))
    # try with trapezoid() but then arrays are needed instead of functions!
    integral_value, _ = quad(utility, 0, 10, args=(l, v, inc, d_kprv))
    # print(-integral_value)
    return -integral_value


def optimize_l(v, inc, d_kprv):
    _l = 0.1
    result = minimize(obj_function, _l, args=(v, inc, d_kprv))
    # print(result)
    optimal_l = result.x[0]
    return optimal_l


def optimize_reco(c0, v, kprv):
    """
    inspired by Bramka's function
    """
    last_integ = 0
    last_lambda = 0
    _lambda = 0
    integs = []
    lambdas = []
    while True:

        t_max = 15
        nsteps = 52 * t_max
        dt = t_max / nsteps

        integ = 0
        for _t in np.linspace(0, t_max, nsteps):
            integ += (c0 - (_lambda * kprv - c0) * v * math.e ** (_lambda * _t)) ** (-eta) * (
                    kprv * (_lambda * _t - 1) - c0 * _t) * v * math.e ** (_t * (rho + _lambda)) * dt

        # stop if integ is nan
        if integ != integ:
            integs = np.array(integs)
            lambdas = np.array(lambdas)
            idx = np.abs(integs).argmin()
            return lambdas[idx]

        if (last_integ < 0 < integ) or (last_integ > 0 > integ):
            return (_lambda + last_lambda) / 2

        last_integ = integ
        last_lambda = _lambda
        _lambda = _lambda + 0.005
        integs.append(last_integ)
        lambdas.append(_lambda)


