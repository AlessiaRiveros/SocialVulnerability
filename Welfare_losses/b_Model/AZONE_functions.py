import math
import numpy as np
import tomli
from scipy.integrate import quad
from scipy.optimize import minimize

with open("config.toml", mode="rb") as fp:
    config = tomli.load(fp)

pi = config['macro']['pi']
rho = config['macro']['rho']
eta = config['macro']['eta']
gdp = config['macro']['gdp']

extreme_poverty = config['macro']['extremepoverty'] * 12


def inc_loss(t, l, v, inc):
    return v * inc * math.e ** (-t * l)


def reco_costs(t, l, d_kprv):
    return d_kprv * l * math.e ** (-t * l)


c_negative = []


def c_t(t, l, v, inc, d_kprv):
    delta_income = inc_loss(t, l, v, inc)
    c_recovery = reco_costs(t, l, d_kprv)

    c = inc - (c_recovery + delta_income)

    if np.all(t < np.array([0])):
        return inc
    elif np.all(c < np.array([0])):
        c_negative.append(c)
        return c
    else:
        return c


def cons_loss(t, l, v, inc, d_kprv):
    d_inc = inc_loss(t, l, v, inc)
    c_reco = reco_costs(t, l, d_kprv)
    return d_inc + c_reco


def utility(t, l, v, inc, d_kprv):
    consumption = c_t(t, l, v, inc, d_kprv)
    return (consumption ** (1 - eta)) / (1 - eta)


def obj_function(l, v, inc, d_kprv):
    # integral_value, _ = quad(utility, 0, 10, args=(v, inc, d_kprv, l))
    # try with trapezoid() but then arrays are needed instead of functions!
    integral_value, _ = quad(utility, 0, 10, args=(l, v, inc, d_kprv))
    # print(-integral_value)
    return -integral_value


def optimize_reco_v1(v, inc, d_kprv):
    _l = 0.1
    result = minimize(obj_function, _l, args=(v, inc, d_kprv))
    # print(result)
    optimal_l = result.x[0]
    return optimal_l


def optimize_reco_v2(c0, v, kprv):
    """
    inspired by Bramka's function but also considering income losses
    """
    last_integ = 0
    last_lambda = 0
    _lambda = 0
    integs = []
    lambdas = []
    while True:

        t_max = 15
        nsteps = 52 * t_max
        dt = t_max / nsteps

        integ = 0
        for _t in np.linspace(0, t_max, nsteps):
            integ += (c0 - (_lambda * kprv - c0) * v * math.e ** (_lambda * _t)) ** (-eta) * (
                    kprv * (_lambda * _t - 1) - c0 * _t) * v * math.e ** (_t * (rho + _lambda)) * dt

        # stop if integ is nan
        if integ != integ:
            integs = np.array(integs)
            lambdas = np.array(lambdas)
            idx = np.abs(integs).argmin()
            return lambdas[idx]

        if (last_integ < 0 < integ) or (last_integ > 0 > integ):
            return (_lambda + last_lambda) / 2

        last_integ = integ
        last_lambda = _lambda
        _lambda = _lambda + 0.005
        integs.append(last_integ)
        lambdas.append(_lambda)


def optimize_reco_v3(c0, v, kprv):
    """
    taken from Bramka's script and modified
    :param c0:
    :param v:
    :param kprv:
    :return:
    """

    last_integ = 0.
    last_lambda = 0.
    _lambda = 0.

    while True:

        t_max = 15
        nsteps = 52 * t_max
        dt = t_max / nsteps

        integ = 0
        # here I don't get nan values
        for _t in np.linspace(0, t_max, nsteps):
            integ += (c0 - kprv * _lambda * v * math.e**(-_lambda * _t))**(-eta) * (kprv * v * (
                    _lambda * _t - 1)) * math.e*(-_t * (rho + _lambda)) * dt

        print(integ, _lambda)
        if (last_integ < 0 and integ > 0) or (last_integ > 0 and integ < 0):
            return (_lambda + last_lambda) / 2

        last_integ = integ
        if last_integ is None: assert (False)

        last_lambda = _lambda
        _lambda += 0.005

        # check for runaway
        if _lambda > 10:
            return last_lambda


def optimize_reco_v4(v):
    """
    compute recovery rate like Walsh and Hallegatte (2020). Seems to not work for any row in the case of Santa Cruz!
    :param v:
    :return:
    """

    last_integ = 0.
    last_lambda = 0.
    _lambda = 0.

    while True:

        t_max = 15
        nsteps = 52 * t_max
        dt = t_max / nsteps

        integ = 0
        # starts negative and keeps on decreasing to very large negative numbers!
        for _t in np.linspace(0, t_max, nsteps):
            integ += (pi - (pi + _lambda) * v * math.e**(-_lambda * _t))**(-eta) * (
                    _t *(pi + _lambda) - 1) * math.e*(-_t * (rho + _lambda)) * dt

        print(integ, _lambda)
        if (last_integ < 0 and integ > 0) or (last_integ > 0 and integ < 0):
            return (_lambda + last_lambda) / 2

        last_integ = integ
        if last_integ is None or last_integ<-100:
            return np.nan

        last_lambda = _lambda
        _lambda += 0.005

        # check for runaway
        if _lambda > 10:
            return last_lambda


def tau(l):
    return np.log(1 / 0.05) / l


# additional functions
def total_inc_loss(l, v, inc):
    integ, error = quad(inc_loss, 0, 15, args=(l, v, inc))
    return integ


def total_reco_costs(l, d_kprv):
    integ, error = quad(reco_costs, 0, 15, args=(l, d_kprv))
    return integ


def total_cons_loss(l, v, inc, d_kprv):
    integ, error = quad(cons_loss, 0, 15, args=(l, v, inc, d_kprv))
    return integ
