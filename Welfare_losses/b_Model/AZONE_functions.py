import numpy as np
import math
import tomli
import os

with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# TODO: try with optimal recovery?
T_prv = 1.5
R_prv = np.log(1/0.05)/T_prv

T_max = 3
n_steps = 50
t_reco = np.linspace(0, T_max, num=n_steps, endpoint=True)

pi = config['pi']
rho = config['rho']
eta = config['eta']
gdp = config['gdp']

extreme_poverty = config['extremepoverty'] * 12


def inc_loss(row):
    d_kprv = row['d_kprv']

    d_inc_prv = []

    for _t in t_reco:
        d_inc_prv.append(d_kprv * math.e**(-_t * R_prv))

    return np.array(d_inc_prv)


# def optimize_reco(row, verbose=False):
#     v = row['v']
#     if v == 0:
#         return 0
#
#     last_integ = None
#     last_lambda = None
#
#     _l = 0.0  # lambda
#     while True:
#
#         if pi - (pi + _l) * v < 0:
#             assert False
#
#         x_max = 15
#         dt_step = 52 * x_max
#
#         integ = 0
#         for _t in np.linspace(0, x_max, dt_step):
#             integ += np.e ** (-_t * (rho + _l)) * ((pi + _l) * _t - 1) * (pi - (pi + _l) * v * np.e ** (-_l * _t)) ** (
#                 -eta)
#
#         if last_integ and ((last_integ < 0 < integ) or (last_integ > 0 > integ)):
#             print('\n Found the Minimum!\n lambda = ',last_lambda,'--> integ = ',last_integ)
#             print('lambda = ',_l,'--> integ = ',integ)
#             return (_l + last_lambda) / 2
#
#         last_integ = integ
#         last_lambda = _l
#         _l += 0.01


# Step 9
def reco_costs(row):
    # TODO: only for private assets?! I had done it for keff assets
    # eq 20
    d_kprv = row['d_kprv']

    c_reco = []
    for _t in t_reco:
        c_reco.append(d_kprv * R_prv * math.e ** (-_t * R_prv))

    return np.array(c_reco)


def cons_loss(row):
    d_inc = inc_loss(row)
    c_reco = reco_costs(row)
    # eq 17 dch = dih + dchreco - Sh
    return np.array(d_inc) + np.array(c_reco)


# Step 12
# Look at well-being losses during recovery
# TODO: wprime = avg_gdp_pc**(-inc_elast) ? wprime = cavg ** -eta, because consumption = income assumption?
# I thought c was consumption loss that is how I did it for hh level

wprime = gdp**(-eta)

# TODO: wellbeing losses during recovery, but equation is different
# _wl = math.e**(-_t*rho)/(1.-eta)*(float(df['income'])**(1.-eta)
#    - (float(df['income'])-d_cons_sum[n_t])**(1.-eta))


def well_loss(row):
    dt = T_max / n_steps
    welf_init = []
    welf_loss, welf_loss_curr = [], []
    welf_loss_cum = 0
    d_cons_sum = cons_loss(row)
    income = row['inc']

    for n_t, _t in enumerate(t_reco):
        # why income?
        _wl = ()
        # _wl = d_cons_sum[n_t]
        _wl = math.e ** (-_t * rho) / (1 - eta) * (income ** (1 - eta) - (income - d_cons_sum[n_t]) ** (1 - eta))
        print(f'{_wl}, {d_cons_sum[n_t]}')
        welf_loss.append(_wl)
        welf_loss_curr.append(_wl / wprime)
        welf_loss_cum += _wl/wprime * dt

    # return welf_loss_cum# np.array(welf_loss) #, welf_loss_cum
    return np.array(welf_loss)
    # TODO: finish following the training despite my doubts, see which first results I get at the AZONE level?
