import numpy as np
import math
import tomli
import os
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.integrate import quad
from scipy.optimize import minimize
from scipy.integrate import trapezoid

with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)


pi = config['pi']
rho = config['rho']
eta = config['eta']
gdp = config['gdp']

extreme_poverty = config['extremepoverty'] * 12


def inc_loss(t, l, v, inc):
    return v * inc * math.e**(-t * l)


def reco_costs(t, l, d_kprv):
    return d_kprv * l * math.e ** (-t * l)


c_negative = []


def c_t(t, l, v, inc, d_kprv):
    delta_income = inc_loss(t, l, v, inc)
    c_recovery = reco_costs(t, l, d_kprv)

    c = inc - (c_recovery + delta_income)

    if np.all(t < np.array([0])):
        return inc
    elif np.all(c < np.array([0])):
        c_negative.append(c)
        return c
    else:
        return c


def cons_loss(t, l, v, inc, d_kprv):
    d_inc = inc_loss(t, l, v, inc)
    c_reco = reco_costs(t, l, d_kprv)
    return d_inc + c_reco


def utility(t, l, v, inc, d_kprv):
    consumption = c_t(t, l, v, inc, d_kprv)
    return (consumption**(1-eta))/(1-eta)


def obj_function(l, v, inc, d_kprv):
    # integral_value, _ = quad(utility, 0, 10, args=(v, inc, d_kprv, l))
    # try with trapezoid() but then arrays are needed instead of functions!
    integral_value, _ = quad(utility, 0, 10, args=(l, v, inc, d_kprv))
    print(-integral_value)
    return -integral_value


def optimize_l(v, inc, d_kprv):
    _l = 0.1
    result = minimize(obj_function, _l, args=(v, inc, d_kprv), bounds=[(0.3, 1000)])
    print(result)
    optimal_l = result.x[0]
    return optimal_l


def plot_hh_cons(t_reco, c0, l, inc_loss_hh, reco_costs_hh, cons_loss_hh):
    """

    :param t_reco: array time
    :param c0: float predisaster consumption, assume c0 = inc0
    :param l: float lambda recovery rate
    :param inc_loss_hh: list or array income loss per household
    :param reco_costs_hh: list or array recovery costs per household
    :param cons_loss_hh: list or array consumption loss per household
    :return: fig
    """

    inc_loss_hh = np.array(inc_loss_hh)
    reco_costs_hh = np.array(reco_costs_hh)
    cons_loss_hh = np.array(cons_loss_hh)

    xmin = -0.25
    xmax = t_reco[-1]
    fs = 10
    ymin = (c0 - cons_loss_hh[0]) * 0.999
    ymax = c0 * 1.001

    def format_func(value, _):
        # Convert the value into a formatted string with spacing
        return "{:,.0f}".format(value)

    tau = np.log(1 / 0.05) / l

    fig, ax = plt.subplots(figsize=(8, 5))

    # change in consumption
    ax.plot(t_reco, c0 - cons_loss_hh, color="b", label="c(t)", ls="--", lw=1.2, zorder=9)
    kwargs = {"color": "b", "linestyle": "--", "linewidth": 1.2}
    ax.vlines(x=0, ymin=c0 - cons_loss_hh[0], ymax=c0, **kwargs)
    ax.hlines(y=c0, xmin=xmin, xmax=0, **kwargs)

    # add c0
    ax.text(xmin * 1.05, c0, "c$_0$", fontsize=fs, ha="right", va="center", color="k", zorder=10)

    # reconstruction cost
    ax.plot(t_reco, c0 - reco_costs_hh, color="green", alpha=0.8, lw=1, label="c$_{reco}$(t)", zorder=2)

    # change in income
    ax.plot(t_reco, c0 - inc_loss_hh, color="purple", alpha=0.8, lw=1, label=r"$\Delta$i", zorder=2)
    kwargs = {"color": "purple", "linestyle": "-", "linewidth": 1, "alpha": 0.8}
    ax.vlines(x=0, ymin=c0 - inc_loss_hh[0], ymax=c0, **kwargs)

    # recovery rate
    ax.plot([], [], " ", label=rf"$\lambda$ = {l:.1f}")

    # recovery time
    ax.axvline(x=tau, color="r", alpha=0.9, lw=0.6)
    ax.text(tau, ymax + 0.3, rf"$\tau$ = {tau:.2f}", fontsize=fs, ha="center", va="bottom", color="r",
            zorder=10)

    # formatting
    ax.yaxis.set_major_formatter(ticker.FuncFormatter(format_func))
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_ylabel('Household consumption, c(t)')
    ax.set_xlabel('Time t after disaster (yrs)')
    ax.legend(loc="lower right")

    return fig