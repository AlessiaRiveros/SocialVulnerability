import numpy as np
import math

T_prv = 1.5
T_pub = 3
R_prv = np.log(1/0.05)/T_prv
R_pub = np.log(1/0.05)/T_pub

T_max = 3
n_steps = 50
t_reco = np.linspace(0, T_max, num=n_steps, endpoint=True)

pi = 83541 / 170129  # average productivity
rho = 12.67 / 100  # discount rate
eta = 1.5
gdp = 22217  # gdp per capita in 2016 in BS


def inc_loss(row):
    d_kprv = row['d_kprv']

    d_inc_prv = []

    for _t in t_reco:
        d_inc_prv.append(d_kprv * math.e**(-_t * R_prv))

    return np.array(d_inc_prv)


# Step 9
def reco_costs(row):
    # TODO: only for private assets?! I had done it for keff assets
    # eq 20
    d_kprv = row['d_kprv']

    c_reco = []
    for _t in t_reco:
        c_reco.append(d_kprv * R_prv * math.e ** (-_t * R_prv))

    return np.array(c_reco)


def cons_loss(row):
    d_inc_prv = inc_loss(row)
    c_reco = reco_costs(row)
    # eq 17 dch = dih + dchreco - Sh
    return np.array(d_inc_prv) + np.array(c_reco)


# Step 12
# Look at well-being losses during recovery
# TODO: wprime = avg_gdp_pc**(-inc_elast) ? wprime = cavg ** -eta, because consumption = income assumption?
# I thought c was consumption loss that is how I did it for hh level

wprime = gdp**(-eta)

# TODO: wellbeing losses during recovery, but equation is different
# _wl = math.e**(-_t*rho)/(1.-eta)*(float(df['income'])**(1.-eta)
#    - (float(df['income'])-d_cons_sum[n_t])**(1.-eta))


def well_loss(row):
    dt = T_max / n_steps
    welf_init = []
    welf_loss, welf_loss_curr = [], []
    welf_loss_cum = 0
    d_cons_sum = cons_loss(row)
    income = row['inc']

    for n_t, _t in enumerate(t_reco):
        _wl = math.e ** (-_t * rho) / (1. - eta) * (income ** (1. - eta) - (income - d_cons_sum[n_t]) ** (1. - eta))
        welf_loss.append(_wl)
        welf_loss_curr.append(_wl / wprime)
        welf_loss_cum += _wl/wprime * dt

    return np.array(welf_loss) #, welf_loss_cum

    # TODO: finish following the training despite my doubts, see which first results I get at the AZONE level?
