import numpy as np
import math
import tomli
import os
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from scipy.integrate import quad
from scipy.optimize import minimize

with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# TODO: try with optimal recovery?
T_prv = 1.5
R_prv = np.log(1/0.05)/T_prv

T_max = 5
n_steps = 500
t_reco = np.linspace(0, T_max, num=n_steps, endpoint=True)

pi = config['pi']
rho = config['rho']
eta = config['eta']
gdp = config['gdp']

extreme_poverty = config['extremepoverty'] * 12


def inc_loss(row, l):
    v = row['v']
    inc = row['inc_hh']
    # l = row['l']

    d_inc = []

    for _t in t_reco:
        d_inc.append(v * inc * math.e**(-_t * l))

    return np.array(d_inc)

# def inc_loss_t(_t, row):
#     v = row['v']
#     inc = row['inc_hh']
#     l = row['l']
#     return v * inc * math.e**(-_t * l)

def reco_costs(row, l):
    # TODO: only for private assets?! I had done it for keff assets
    # eq 20
    d_kprv = row['d_kprv_hh']
    # l = row['l']

    c_reco = []
    for _t in t_reco:
        c_reco.append(d_kprv * l * math.e ** (-_t * l))

    return np.array(c_reco)

# def reco_costs_t(_t, row):



def cons_loss(row, l):
    d_inc = inc_loss(l, row)
    c_reco = reco_costs(l, row)
    # eq 17 dch = dih + dchreco - Sh
    return np.array(d_inc) + np.array(c_reco)


def utility(row, l):
    c0 = row['inc_hh']
    c_t = c0 - cons_loss(l, row)
    u_t = c_t**(1-eta)/(1-eta)
    return np.array(u_t)


def obj_function(row, l=0.5):
    integral_value, _ = quad(utility, 0, 10, args=(row, l))
    return integral_value


def optimize_l(row):
    _l = 0.5
    result = minimize(obj_function, _l, args=(row), bounds=[(0.3, 1000)])
    optimal_l = result.x[0]
    return optimal_l




def well_loss(row):
    dt = T_max / n_steps
    welf_init = []
    welf_loss, welf_loss_curr = [], []
    welf_loss_cum = 0
    d_cons_sum = cons_loss(row)
    income = row['inc']

    for n_t, _t in enumerate(t_reco):
        # why income?
        _wl = ()
        # _wl = d_cons_sum[n_t]
        _wl = math.e ** (-_t * rho) / (1 - eta) * (income ** (1 - eta) - (income - d_cons_sum[n_t]) ** (1 - eta))
        print(f'{_wl}, {d_cons_sum[n_t]}')
        welf_loss.append(_wl)
        welf_loss_curr.append(_wl / wprime)
        welf_loss_cum += _wl/wprime * dt

    # return welf_loss_cum# np.array(welf_loss) #, welf_loss_cum
    return np.array(welf_loss)
    # TODO: finish following the training despite my doubts, see which first results I get at the AZONE level?


def plot_hh_cons(t_reco, c0, l, inc_loss_hh, reco_costs_hh, cons_loss_hh):
    """

    :param t_reco: array time
    :param c0: predisaster consumption, assume c0 = inc0
    :param l: lambda recovery rate
    :param inc_loss_hh: array income loss per household
    :param reco_costs_hh: array recovery costs per household
    :param cons_loss_hh: array consumption loss per household
    :return: fig
    """

    xmin = -0.25
    xmax = t_reco[-1]
    fs = 10
    ymin = (c0 - cons_loss_hh[0]) * 0.999
    ymax = c0 * 1.001

    def format_func(value, _):
        # Convert the value into a formatted string with spacing
        return "{:,.0f}".format(value)

    tau = np.log(1 / 0.05) / l

    fig, ax = plt.subplots(figsize=(8, 5))

    # change in consumption
    ax.plot(t_reco, c0 - cons_loss_hh, color="b", label="c(t)", ls="--", lw=1.2, zorder=9)
    kwargs = {"color": "b", "linestyle": "--", "linewidth": 1.2}
    ax.vlines(x=0, ymin=c0 - cons_loss_hh[0], ymax=c0, **kwargs)
    ax.hlines(y=c0, xmin=xmin, xmax=0, **kwargs)

    # add c0
    ax.text(xmin * 1.05, c0, "c$_0$", fontsize=fs, ha="right", va="center", color="k", zorder=10)

    # reconstruction cost
    ax.plot(t_reco, c0 - reco_costs_hh, color="green", alpha=0.8, lw=1, label="c$_{reco}$(t)", zorder=2)

    # change in income
    ax.plot(t_reco, c0 - inc_loss_hh, color="purple", alpha=0.8, lw=1, label=r"$\Delta$i", zorder=2)
    kwargs = {"color": "purple", "linestyle": "-", "linewidth": 1, "alpha": 0.8}
    ax.vlines(x=0, ymin=c0 - inc_loss_hh[0], ymax=c0, **kwargs)

    # recovery rate
    ax.plot([], [], " ", label=rf"$\lambda$ = {l:.1f}")

    # recovery time
    ax.axvline(x=tau, color="r", alpha=0.9, lw=0.6)
    ax.text(tau, ymax + 0.3, rf"$\tau$ = {tau:.2f}", fontsize=fs, ha="center", va="bottom", color="r",
            zorder=10)

    # formatting
    ax.yaxis.set_major_formatter(ticker.FuncFormatter(format_func))
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_ylabel('Household consumption, c(t)')
    ax.set_xlabel('Time t after disaster (yrs)')
    ax.legend(loc="lower right")

    return fig