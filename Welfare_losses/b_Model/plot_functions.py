import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import matplotlib.colors as colors
from matplotlib.colors import Normalize
import numpy as np
from mpl_toolkits.axes_grid1 import make_axes_locatable
import tomli
from scipy.integrate import simps

with open("../../config.toml", mode="rb") as fp:
# with open("config.toml", mode="rb") as fp:
    config = tomli.load(fp)

rho = config['macro']['rho']
eta = config['macro']['eta']
c_mean = config['income']['JICA'] * 12


def format_func(value, _):
    # Convert the value into a formatted string with spacing
    return "{:,.0f}".format(value)


def plot_spatial_var(gdf, var):
    """

    :param gdf: geodataframe
    :param var: column name to plot
    :return:
    """
    # dictionary of vars and labels?

    var_dict = {'v': 'Vulnerability (-)',
                'kprv': 'Private Assets (Bs/hh)',
                'inc': 'Income (Bs/yr/hh)',
                'inc-mean': 'Income - mean (Bs/yr/hh)',
                'd_inc': 'Income Loss (Bs/yr/hh)',
                'd_kprv': 'Private Asset Losses (Bs/hh)',
                'l': 'Recovery Rate (-)',
                'tau': 'Recovery Time (yrs)',
                'tot_d_inc': 'Total Income Loss (Bs/hh)',
                'tot_c_reco': 'Total Reconstruction Costs (Bs/hh)',
                'total_cons_loss': 'Total Consumption Loss (Bs/hh)',
                'W': 'Welfare Loss (utils)',
                'Ceq': 'Consumption Equivalent (Bs/hh)'
                }

    fig, ax = plt.subplots(figsize=(7, 5))

    ax_divider = make_axes_locatable(ax)
    cax = ax_divider.append_axes("right", size="5%", pad="1%")
    cmap = 'OrRd'
    norm = None
    if var in ['kprv', 'd_kprv']:
        format = format_func

    elif var == 'inc':
        format = format_func
        # cmap
        cmap = 'RdBu'
        # normalize data
        min_val = gdf['inc'].min()
        max_val = gdf['inc'].max()
        norm = colors.TwoSlopeNorm(vcenter=c_mean, vmin=min_val, vmax=max_val)
    else:
        format = None
    gdf.plot(column=var, ax=ax, cax=cax, cmap=cmap, norm=norm, legend=True, legend_kwds={"label": var_dict[var], 'format':format})
    ax.set_axis_off()
    plt.tight_layout()

    return fig


def plot_diff(gdf):

    vmax = min(gdf['d_kprv'].max(), gdf['Ceq'].max())
    label = '(Bs/hh)'

    fig, ax = plt.subplots(1, 3, figsize=(12, 4))

    ax0_divider = make_axes_locatable(ax[0])
    ax1_divider = make_axes_locatable(ax[1])
    ax2_divider = make_axes_locatable(ax[2])

    cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
    cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")
    cax2 = ax2_divider.append_axes("right", size="5%", pad="1%")

    gdf.plot(column='d_kprv', ax=ax[0], cax=cax0, cmap='OrRd', vmax=vmax, legend=True, legend_kwds={"label": label})
    gdf.plot(column='Ceq', ax=ax[1], cax=cax1, cmap='OrRd', vmax=vmax, legend=True, legend_kwds={"label": label})
    gdf.plot(column='diff_d_kprv-Ceq', ax=ax[2], cax=cax2, cmap='OrRd', legend=True, legend_kwds={"label": label})

    ax[0].title.set_text('$\Delta_k{prv}$')
    ax[1].title.set_text('$C_{eq}$')
    ax[2].title.set_text(r'$\Delta_k{prv}$ - $C_{eq}$')

    ax[0].set_axis_off()
    ax[1].set_axis_off()
    ax[2].set_axis_off()

    plt.tight_layout()

    return fig


def plot_utility(t_reco, u, l):
    """
    plots utility over time given a certain recovery rate lambda
    :param t_reco: list or array time after disaster
    :param u: list or array utility
    :param l: float lambda recovery rate
    :return:
    """
    t_reco = np.array(t_reco)
    u = np.array(u)

    fig, ax = plt.subplots(figsize=(8, 5))

    ax.plot(t_reco, u, label=rf"$\lambda$ = {l:.1f}")
    ax.set_ylabel('u(t)')
    ax.set_xlabel('Time t after disaster (yrs)')
    ax.legend()
    plt.tight_layout()

    return fig


def plot_w_integ(t_reco, u0, u):
    t_reco = np.array(t_reco)
    u = np.array(u)
    # with discount rate
    integ = (u0 - u) * np.e ** (-rho * t_reco)
    integral_W = simps(integ, dx=t_reco[1] - t_reco[2])
    Ceq = integral_W / c_mean**(-eta)

    # without discount rate
    integ2 = u0 - u
    integral_W2 = simps(integ2, dx=t_reco[1] - t_reco[2])
    Ceq2 = integral_W2 / c_mean ** (-eta)

    y1 = np.zeros(t_reco.shape)

    fig, ax = plt.subplots(figsize=(8, 5))

    ax.plot(t_reco, integ, color="blue", label=rf"(u$_0$ - u(t)) * e$^{{-\rho t}}$")
    ax.fill_between(t_reco,
                    y1,
                    integ,
                    label=f"$\Delta$W = {integral_W:.6f}\nC$_{{eq}}$ = {Ceq:.3f} (Bs)",
                    color="blue",
                    alpha=0.4)

    ax.plot(t_reco, integ2, color="green", label=rf"(u$_0$ - u(t))")
    ax.fill_between(t_reco,
                    y1,
                    integ2,
                    label=f"$\Delta$W = {integral_W2:.6f}\nC$_{{eq}}$ = {Ceq2:.3f} (Bs)",
                    color="green",
                    alpha=0.4)

    ax.set_ylabel('utility (utils)')
    ax.set_xlabel('Time t after disaster (yrs)')
    ax.legend()
    return fig, integral_W, Ceq


def plot_hh_cons(t_reco, c0, l, inc_loss_hh, reco_costs_hh, cons_loss_hh):
    """
    plots in a single figure the hh consumption, the hh reconstruction costs, and the hh income losses

    :param t_reco: list or array time after disaster
    :param c0: float predisaster consumption, assume c0 = inc0
    :param l: float lambda recovery rate
    :param inc_loss_hh: list or array income loss per household
    :param reco_costs_hh: list or array recovery costs per household
    :param cons_loss_hh: list or array consumption loss per household
    :return: fig
    """

    t_reco = np.array(t_reco)
    inc_loss_hh = np.array(inc_loss_hh)
    reco_costs_hh = np.array(reco_costs_hh)
    cons_loss_hh = np.array(cons_loss_hh)

    xmin = -0.25
    xmax = t_reco[-1]
    fs = 10
    ymin = (c0 - cons_loss_hh[0]) * 0.999
    ymax = c0 * 1.001

    tau = np.log(1 / 0.05) / l

    fig, ax = plt.subplots(figsize=(8, 5))

    # change in consumption
    ax.plot(t_reco, c0 - cons_loss_hh, color="b", label="c(t)", ls="--", lw=1.2, zorder=9)
    kwargs = {"color": "b", "linestyle": "--", "linewidth": 1.2}
    ax.vlines(x=0, ymin=c0 - cons_loss_hh[0], ymax=c0, **kwargs)
    ax.hlines(y=c0, xmin=xmin, xmax=0, **kwargs)

    # add c0
    ax.text(xmin * 1.05, c0, "c$_0$", fontsize=fs, ha="right", va="center", color="k", zorder=10)

    # reconstruction cost
    ax.plot(t_reco, c0 - reco_costs_hh, color="green", alpha=0.8, lw=1, label="c$_{reco}$(t)", zorder=2)

    # change in income
    ax.plot(t_reco, c0 - inc_loss_hh, color="purple", alpha=0.8, lw=1, label=r"$\Delta$i", zorder=2)
    kwargs = {"color": "purple", "linestyle": "-", "linewidth": 1, "alpha": 0.8}
    ax.vlines(x=0, ymin=c0 - inc_loss_hh[0], ymax=c0, **kwargs)

    # recovery rate
    ax.plot([], [], " ", label=rf"$\lambda$ = {l:.1f}")

    # recovery time
    ax.axvline(x=tau, color="r", alpha=0.9, lw=0.6)
    ax.text(tau, ymax + 0.3, rf"$\tau$ = {tau:.2f}", fontsize=fs, ha="center", va="bottom", color="r",
            zorder=10)

    # formatting
    ax.yaxis.set_major_formatter(ticker.FuncFormatter(format_func))
    ax.set_xlim(xmin, xmax)
    ax.set_ylim(ymin, ymax)
    ax.set_ylabel('Household consumption, c(t)')
    ax.set_xlabel('Time t after disaster (yrs)')
    ax.legend(loc="lower right")

    return fig
