##
import os
import geopandas as gpd
import pandas as pd
import tomli
from shapely.geometry import box
from Welfare_losses.b_Model.AZONE_functions import *
from Welfare_losses.b_Model.plot_functions import *

with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# ----------------- global variables and configurations  -----------------
pi = config['pi']
rho = config['rho']
eta = config['eta']
extreme_poverty = config['extremepoverty'] * 12
method = 'total'  # total or average for aggregating at AZONE
T = 10  # return period
building_type = 'residential'  # consider only residential buildings
pd.set_option('display.max_columns', None)

tax = 0.13  # ?

# ----------------- load data -----------------
pdir = r'p:\11209200-020-sociale-kwetsbaarheid'

# AZONE geometry
gdf = gpd.read_file(os.path.join(pdir, 'Data', 'Income', 'AZONE.shp'))

# FIAT data at AZONE level -> total damages of residential buildings
df1 = pd.read_csv(os.path.join(pdir, 'Data', 'FIAT', 'AZONE', f'AZONE_T{T}_{building_type}_{method}_damages.csv'),
                  usecols=['IDazone', 'TD_E', 'TD_E_hh', 'RelDam', 'TotPotDam'])

# income data at AZONE level -> monthly income per household at AZONE level
df2 = pd.read_csv(os.path.join(pdir, 'Data', 'Income', 'AZONE_income.csv'), usecols=['ID', 'Income'])

# ----------------- process data -----------------
# rename id
df1 = df1.rename(columns={'IDazone': 'ID'})

# merge FIAT and income dataframes
df = pd.merge(df1, df2, how='inner', on='ID')

# rename columns for simplicity
df = df.rename(columns={'TotPotDam': 'kprv', 'Income': 'inc_hh', 'RelDam': 'v', 'TD_E': 'd_kprv', 'TD_E_hh': 'd_kprv_hh'})

# to translate it to per hh
df["kprv_hh"] = df["kprv"] * df["d_kprv_hh"] / df["d_kprv"]

# remove inf, 0 values
df = df.replace([np.inf, -np.inf, 0], np.nan)
df['inc_hh'] = df['inc_hh'] * 12  # convert to yearly

# remove rows with nan values
df = df.dropna()

# remove kprv and d_kprv rows
df = df.drop(columns=['kprv', 'd_kprv'])

# df['v'] *= np.random.uniform(0.8, 1.2)

# ## try for ID = 109 and ID = 45
# # print(df.sort_values(by=['v'], ascending=False))
# index = 109
# df = df.loc[df['ID'].isin([index])]
#
# ##
# v = df['v'].item()
# inc = df['inc_hh'].item()
# d_kprv = df['d_kprv_hh'].item()
# k_prv = df['kprv_hh'].item()
#
# print(f"v={v:.3f} inc={inc:.0f} d_kprv={d_kprv:.0f} k_prv={k_prv:.0f}")
#
# d_inc = []
# c_reco = []
# d_c = []
# u = []
#
# l = optimize_recovery(inc, v, k_prv)
# l = round(l, 4)
# print(l)
# t_reco = np.linspace(0, 3, 50, endpoint=True)
# # l=2
# # l = optimize_l(v, inc, d_kprv)
# for t in t_reco:
#     d_inc.append(inc_loss(t, l, v, inc))
#     c_reco.append(reco_costs(t, l, d_kprv))
#     d_c.append(cons_loss(t, l, v, inc, d_kprv))
#     u.append(utility(t, l, v, inc, d_kprv))

# ## figures
# fig = plot_utility(t_reco, u, l)
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', f'{index}_utility_hh.png'))
#
# fig = plot_hh_cons(t_reco, inc, l, d_inc, c_reco, d_c)
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', f'{index}_consumption_change_hh.png'))
# plt.show()

##

# boundaries to exclude areas where FIAT results not available
xmin = -63.26
xmax = -63.05
ymin = -17.9
ymax = -17.65

bbox = box(xmin, ymin, xmax, ymax)
gdf = gpd.clip(gdf, mask=bbox)

# visualize
gdf['inc'] = df['inc_hh']
gdf['kprv'] = df['kprv_hh']
gdf['d_kprv'] = df['d_kprv_hh']
gdf['v'] = df['v']

# ## plot all the variables spatially
# fig = plot_spatial_var(gdf, 'inc')
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'inc_hh.png'))
# fig = plot_spatial_var(gdf, 'kprv')
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'kprv_hh.png'))
# fig = plot_spatial_var(gdf, 'd_kprv')
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'd_kprv_hh.png'))
# fig = plot_spatial_var(gdf, 'v')
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'v_hh.png'))
# plt.show()

## compute optimal recovery rate for all AZONES and plot it
df['l'] = df.apply(lambda row: optimize_reco_v2(row['inc_hh'], row['v'], row['kprv_hh']), axis=1)
# df['l'] = df.apply(lambda row: optimize_recovery_v4(row['v']), axis=1)
# let's remove the lambdas that are equal to 5e-03
df.loc[df['l'] == 5e-03, 'l'] = np.nan

gdf['l'] = df['l']
fig = plot_spatial_var(gdf, 'l')
plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'l_hh.png'))
df['tau'] = df.apply(lambda row: tau(row['l']), axis=1)
gdf['tau'] = df['tau']
print(df)
df = df.dropna()
gdf = gdf.dropna()
fig = plot_spatial_var(gdf, 'tau')
plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'tau_hh.png'))
plt.show()





