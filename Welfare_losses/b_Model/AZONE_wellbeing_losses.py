##
import os
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
import geopandas as gpd
import numpy as np
from mpl_toolkits.axes_grid1 import make_axes_locatable
from shapely.geometry import box
# from AZONE_functions import *
import tomli
with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# ----------------- global variables and configurations  -----------------
pi = config['pi']
rho = config['rho']
eta = config['eta']
extreme_poverty = config['extremepoverty'] * 12
method = 'total'  # total or average for aggregating at AZONE
T = 10  # return period
building_type = 'residential'  # consider only residential buildings
pd.set_option('display.max_columns', None)

tax = 0.13  # ?

# ----------------- load data -----------------
pdir = r'p:\11209200-020-sociale-kwetsbaarheid'

# AZONE geometry
gdf = gpd.read_file(os.path.join(pdir, 'Data', 'Income', 'AZONE.shp'))

# FIAT data at AZONE level -> total damages of residential buildings
df1 = pd.read_csv(os.path.join(pdir, 'Data', 'FIAT', 'AZONE', f'AZONE_T{T}_{building_type}_{method}_damages.csv'),
                  usecols=['IDazone', 'TD_E', 'TD_E_hh', 'RelDam', 'TotPotDam'])

# income data at AZONE level -> monthly income per household at AZONE level
df2 = pd.read_csv(os.path.join(pdir, 'Data', 'Income', 'AZONE_income.csv'), usecols=['ID', 'Income'])

# ----------------- process data -----------------
# rename id
df1 = df1.rename(columns={'IDazone': 'ID'})

# merge FIAT and income dataframes
df = pd.merge(df1, df2, how='inner', on='ID')

# rename columns for simplicity
df = df.rename(columns={'TotPotDam': 'kprv', 'Income': 'inc_hh', 'RelDam': 'v', 'TD_E': 'd_kprv', 'TD_E_hh': 'd_kprv_hh'})

# to translate it to per hh
df["kprv_hh"] = df["kprv"] * df["d_kprv_hh"] / df["d_kprv"]

# remove inf, 0 values
df = df.replace([np.inf, -np.inf, 0], np.nan)
df['inc_hh'] = df['inc_hh'] * 12  # convert to yearly

# Step 1
# income=consumption

# df['keff'] = df['inc']/pi + df['kprv']

# df = df.loc[df['ID'].isin([22, 23, 109])]

df['v'] *= np.random.uniform(0.8, 1.2)

# boundaries to exclude areas where FIAT results not available
xmin = -63.26
xmax = -63.05
ymin = -17.9
ymax = -17.65

bbox = box(xmin, ymin, xmax, ymax)
gdf = gpd.clip(gdf, mask=bbox)

# visualize
gdf['inc_hh'] = df['inc_hh']
gdf['kprv_hh'] = df['kprv_hh']
gdf['d_kprv_hh'] = df['d_kprv_hh']
gdf['v'] = df['v']

gdf.plot(column='d_kprv_hh', legend=True)

# try for ID = 109 and ID = 45
df = df.loc[df['ID'].isin([45, 109])]

# v = 0.013843
# inc_hh = 42000.0

v = 0.023681
inc_hh = 18000.0

t = np.linspace(0, 5, 100)
fig, ax = plt.subplots()
# try with different recovery times
for l in [3,6,9]:
    d_inc_hh = []

    for dt in t:
        d_inc_hh_dt = v * inc_hh * math.e**(-l*dt)
        d_inc_hh.append(d_inc_hh_dt)

    ax.plot(t, d_inc_hh, label=f"lambda {l}")
plt.legend()
plt.show()


# l = df.apply(optimize_reco, axis=1).to_list()
# tau = np.log(1/0.05)/ l
# print('lambda: ', l)
# print('tau:', tau)

# # ----------------- plotting -----------------
# # TODO: plotting of intermediate steps as well
# # what about focusing only on the inner ring first? or selecting a couple of AZONEs to compare at hh level and at AZONE
#
# # population?
#
# # yearly income per household
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# gdf.plot(column='inc', ax=ax, cax=cax, legend=True, legend_kwds={"label": "Bs/yr/hh"})
# ax.set_title('Pre-disaster income')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Pre-disaster income.png'))
#
# # kprv
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# gdf.plot(column='kprv', ax=ax, cax=cax, legend=True, legend_kwds={"label": "Bs"})
# ax.set_title('Pre-disaster private assets')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Private Capital.png'))
#
# # d_kprv
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# gdf.plot(column='d_kprv', ax=ax, cax=cax, legend=True, legend_kwds={"label": "Bs"})
# ax.set_title('Post-disaster private asset loss')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Private Capital Loss.png'))
#
#
# # d_inc
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# gdf.plot(column='d_inc', ax=ax, cax=cax, legend=True, legend_kwds={"label": "Bs"})
# ax.set_title('Post-disaster income loss')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Income Loss.png'))
#
# # inc0 - d_inc
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# gdf.plot(column='diff_inc', ax=ax, cax=cax, legend=True, legend_kwds={"label": "Bs"})
# ax.set_title('inc0 - d_inc')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Change in income.png'))
#
# # c_reco
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# cax = ax_divider.append_axes("right", size="5%", pad="1%")
# gdf.plot(column='d_inc', ax=ax, cax=cax, legend=True, legend_kwds={"label": "Bs"})
# ax.set_title('Post-disaster income loss')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Income Loss.png'))
#
#
# # variables = {'v': 'Vulnerability',
# #              'keff': 'Effective Capital',
# #              'd_keff': 'Effective Capital Loss',
# #              'kprv': 'Private Capital',
# #              'inc': 'Income',
# #              'd_inc': 'Income Loss',
# #              'd_kprv': 'Private Capital Loss',
# #             'loss': 'Cumulated Wellbeing Loss'}
# #
# # for k, v in variables.items():
# #     fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# #     ax_divider = make_axes_locatable(ax)
# #     ax.set_axis_off()
# #     cax = ax_divider.append_axes("right", size="5%", pad="1%")
# #     gdf.plot(column=k, ax=ax, cax=cax, legend=True, legend_kwds={"label": ""})
# #     ax.set_title(v)
# #     plt.tight_layout()
# #     plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', f'{v}.png'))
#
# ##
# # for dynamic variables select some AZONES for visualization?
# sel_ids = [22, 23, 109]
# df = df.loc[df['ID'].isin(sel_ids)]
# income_loss = df.apply(inc_loss, axis=1).to_list()
# consumption_loss = df.apply(cons_loss, axis=1).to_list()
# recons_costs = df.apply(reco_costs, axis=1).to_list()
# # wellbeing_loss = df.apply(well_loss, axis=1).to_list()
# t_reco = np.linspace(0, T_max, num=n_steps, endpoint=True)
# #
# fig, ax = plt.subplots(1, 1, figsize=(7, 5))
# ax_divider = make_axes_locatable(ax)
# ax.set_axis_off()
# gdf.boundary.plot(ax=ax)
# gdf[gdf['ID']==22].plot(ax=ax, color='b', legend=True)
# gdf[gdf['ID']==23].plot(ax=ax, color='r', legend=True)
# gdf[gdf['ID']==109].plot(ax=ax, color='y', legend=True)
# ax.set_title('Selected AZONEs')
# plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', 'Selected AZONEs.png'))
#
# fig, ax = plt.subplots(1, len(sel_ids), figsize=(11, 4))
# for i, var in enumerate(sel_ids):
#     # ax[i].plot(recons_costs[i], label='$c_{reco}$(t)')
#     ax[i].plot(consumption_loss[i], label='$c_{h}$(t)')
#     # ax[i].plot(income_loss[i], label=r'$\Delta$i')
#     # ax[i].plot(wellbeing_loss[i], label='$\Delta{W}$(t)')
#     ax[i].invert_yaxis()
#     ax[i].set_ylim(top=0)
#     ax[i].set_xlim(left=0)
#     ax[i].set_title(f'AZONE {var}')
# plt.legend()
# #
# # fig, ax = plt.subplots(1, len(sel_ids), figsize=(11, 4))
# # for i, var in enumerate(sel_ids):
# #     # before disaster
# #     ax[i].plot([t_reco[0], t_reco[-1]], [df['inc'].iloc[i], df['inc'].iloc[i]], label='$c_0$')
# #     ax[i].plot(t_reco, df['inc'].iloc[i] - consumption_loss[i], label='c(t)')
# #     # ax[i].plot([t_reco[0], t_reco[-1]], [extreme_poverty, extreme_poverty], label='extreme poverty')
# #     ax[i].set_xlim(left=0)
# #     ax[i].set_title(f'AZONE {var}')
# # plt.legend()
# # # recovery_costs
# # # cons_loss
# # print(df)
#
# plt.show()

