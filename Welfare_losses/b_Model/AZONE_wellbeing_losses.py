import os
import pandas as pd
import numpy as np
import math
import matplotlib.pyplot as plt
import geopandas as gpd
from mpl_toolkits.axes_grid1 import make_axes_locatable
from shapely.geometry import box
from AZONE_functions import *
import tomli
with open(r"p:\11209200-020-sociale-kwetsbaarheid\Data\config.toml", mode="rb") as fp:
    config = tomli.load(fp)
# global variables
pi = config['pi']
rho = config['rho']
eta = config['eta']
extreme_poverty = config['extremepoverty'] * 12


pdir = r'p:\11209200-020-sociale-kwetsbaarheid'
building_type = 'residential'
method = 'total'
T = 10
pd.set_option('display.max_columns', None)


gdf = gpd.read_file(os.path.join(pdir, 'Data', 'Income', 'AZONE.shp'))
# FIAT data at AZONE level
df1 = pd.read_csv(os.path.join(pdir, 'Data', 'FIAT', 'AZONE', f'AZONE_T{T}_{building_type}_{method}_damages.csv'),
                  usecols=['IDazone', 'TD_E', 'RelDam'])
# IDazone
# income data at AZONE level
df2 = pd.read_csv(os.path.join(pdir, 'Data', 'Income', 'AZONE_income.csv'), usecols=['ID', 'Income'])
# ID

# rename
df1 = df1.rename(columns={'IDazone': 'ID'})
# merge dataframes
df = pd.merge(df1, df2, how='inner', on='ID')
df = df.rename(columns={'TD_E': 'kprv', 'Income': 'inc', 'RelDam': 'v'})
df['inc'] = df['inc'] * 12 # convert to yearly

# Step 1
# Assume saving rate=0%, income = consumption
scaling_factor = 0.1


public_assets = 0.2
df['kprv'] = df['kprv'] * scaling_factor

df['keff'] = df['inc']/pi + df['kprv']
# df['keff'] = df['kprv'] / (1-public_assets)
# df = df.loc[df['ID'].isin([22, 23, 109])]

df['tax'] = 1 - df['inc'] / (df['keff'] * pi)

df['v'] *= np.random.uniform(0.8, 1.2)

df['d_keff'] = df['keff'] * df['v']
df['d_kprv'] = df['kprv'] * df['v']

df['d_inc'] = df['d_keff'] * (1 - df['tax']) * pi

df['loss'] = df.apply(well_loss, axis=1)



# boundaries to exclude areas where FIAT results not available
xmin = -63.26
xmax = -63.05
ymin = -17.9
ymax = -17.65

bbox = box(xmin, ymin, xmax, ymax)
gdf = gpd.clip(gdf, mask=bbox)

gdf['keff'] = df['keff']
gdf['d_keff'] = df['d_keff']
gdf['kprv'] = df['kprv']
gdf['d_kprv'] = df['d_kprv']
gdf['d_inc'] = df['d_inc']
gdf['inc'] = df['inc']
gdf['v'] = df['v']
gdf['loss'] = df['loss']


# ----------------- plotting -----------------
# TODO: plotting of intermediate steps as well
# what about focusing only on the inner ring first? or selecting a couple of AZONEs to compare at hh level and at AZONE
#
variables = {'v': 'Vulnerability',
             'keff': 'Effective Capital',
             'd_keff': 'Effective Capital Loss',
             'kprv': 'Private Capital',
             'inc': 'Income',
             'd_inc': 'Income Loss',
             'd_kprv': 'Private Capital Loss',
            'loss': 'Cumulated Wellbeing Loss'}

for k, v in variables.items():
    fig, ax = plt.subplots(1, 1, figsize=(7, 5))
    ax_divider = make_axes_locatable(ax)
    cax = ax_divider.append_axes("right", size="5%", pad="1%")
    gdf.plot(column=k, ax=ax, cax=cax, legend=True)
    ax.set_title(v)
    plt.savefig(os.path.join(pdir, 'Figures', 'Welfare', f'{v}.png'))


# for dynamic variables select some AZONES for visualization?
sel_ids = [22, 23, 109]
df = df.loc[df['ID'].isin(sel_ids)]
income_loss = df.apply(inc_loss, axis=1).to_list()
consumption_loss = df.apply(cons_loss, axis=1).to_list()
recons_costs = df.apply(reco_costs, axis=1).to_list()
wellbeing_loss = df.apply(well_loss, axis=1).to_list()
t_reco = np.linspace(0, T_max, num=n_steps, endpoint=True)

fig, ax = plt.subplots(1, len(sel_ids), figsize=(11, 4))
for i, var in enumerate(sel_ids):
    ax[i].plot(consumption_loss[i], label='c(t)')
    ax[i].plot(income_loss[i], label=r'$\Delta$i')
    ax[i].invert_yaxis()
    ax[i].set_ylim(top=0)
    ax[i].set_xlim(left=0)
    ax[i].set_title(f'AZONE {var}')
plt.legend()

fig, ax = plt.subplots(1, len(sel_ids), figsize=(11, 4))
for i, var in enumerate(sel_ids):
    # before disaster
    ax[i].plot([t_reco[0], t_reco[-1]], [df['inc'].iloc[i], df['inc'].iloc[i]], label='$c_0$')
    ax[i].plot(t_reco, df['inc'].iloc[i] - consumption_loss[i], label='c(t)')
    # ax[i].plot([t_reco[0], t_reco[-1]], [extreme_poverty, extreme_poverty], label='extreme poverty')
    ax[i].set_xlim(left=0)
    ax[i].set_title(f'AZONE {var}')
plt.legend()
# recovery_costs
# cons_loss
print(df)

plt.show()

