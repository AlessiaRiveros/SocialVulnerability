##
import pandas as pd
import os
import seaborn as sns
import matplotlib.pyplot as plt
from scipy import integrate, optimize
import numpy as np
from functions import optimize_reco, cons_change, floor
from scipy.stats import probplot

pdir = r'p:\11209200-020-sociale-kwetsbaarheid'

pd.set_option('display.max_columns', None)

# productivity = output-side real GDP / capital stock from PWT
# prod = cgdpo / cn
prod = 83541 / 170129

# fraction affected by return period from FIAT output
f2 = 0.016
f10 = 0.039

# elasticity of the marginal utility of consumption
# 1.5 in line with Hallegatte et al 2016 and Walsh and Hallegatte 2019
elast = 1.5

# discount rate from J. A. Rueda-Gallardo 2020 (find one corresponding to 2016)
disc = 12.67 / 100

# subsistence line from INE per person per month in Bs
# convert to years as reconstruction is measured in years
poverty = 804.8 * 12
extreme_poverty = 395.3 * 12

df = pd.read_spss(os.path.join(pdir, 'Data', 'INE', 'Bases_EPF_2015-2016', 'EPF1516_Persona Ingreso.sav'))
df_home = pd.read_csv(os.path.join(pdir, 'Data', 'INE', 'processed', 'EPF1516_Vivienda_processed.csv'))

# filter to area of interest dept = Santa Cruz and urban
df = df.loc[(df['area'] == 'Urbana') & (df['dept'] == '07 Santa Cruz')]

# for testing keep only 50 rows
# df = df.iloc[:20]

# convert folio to int
df['folio'] = df['folio'].astype('int64')
# seccion4: ingresos laborales
# seccion5: ingresos no laborales

variable = {
    's4_17a': 'Liquid Salary (Amount)',
    's4_17b': 'Liquid Salary (Frequency)',
    's4_18a': 'Bonus (Amount) Received',
    's4_18b': 'Christmas Bonus (Amount)',
    's4_22a1': 'Total Income in Primary Occupation (Amount)',
    's4_22a2': 'Total Income in Primary Occupation (Frequency)',
    'ysal1net': 'Salary',
    'ysal1ben_1': 'Bonus',
    'ysal1ben_2': 'Christmas bonus',
    'ysal1ben': 'Total benefits from salaried employment - 1st employment',
    'ysal2ben': 'Total benefits from salaried employment - 2nd employment',
    'ym_especie': 'Total labor income',
    'y_monetario': 'Total labor and non-labor income', # income ih
    # Sumatoria total de ingresos monetarios e ingresos no mometarios, mensualizado, por hogar?
    'ym_transferencia_gob': 'Total transfers from Gov',
    'ym_transferencia_hog': 'Transferencias entre hogares por remesas o internas',
    'ym_transferencia_tot': 'Total transfers from gov, soc security or from other hh'
}

##
# replace NaN in i labor and i h (labor and non labor)
df['y_monetario'] = df['y_monetario'].fillna(0)
df['ym_especie'] = df['ym_especie'].fillna(0)


# groupy by hh
num_cols = df.select_dtypes(include='number').columns
df = df[num_cols].fillna(0)
df_hh = df.groupby('folio').sum()


# Csp gov spending on social protection
# transfers received from friends and family added to social transfers
df['isp'] = df['ym_transferencia_gob'] + df['ym_transferencia_hog'] + df['ym_transferencia_ss']
Csp = df['isp'].sum()

# flat income tax that finances social programs
tax = Csp / df['y_monetario'].sum()

# effective capital stock
df['keff'] = (df['y_monetario'] - df['ym_especie']) / (1-tax) / prod

# merge on folio dwelling table with income to include vulnerability
# df.merge(df_home, how='inner', on='folio')
df = pd.merge(df, df_home, left_on='folio', right_on='folio')

# change in keff
df['dkeff'] = df['keff'] * df['v']

# total exposed assets K
K = (df['dkeff']).sum()

# total asset losses L
L10 = K * f10
L2 = K * f2

# replace NaN in social transfers by 0
df['isp'] = df['isp'].fillna(0)

# change in social transfers
df['disp10'] = L10/K * df['isp']
df['disp2'] = L2/K * df['isp']

# income losses
df['dih10'] = (1-tax) * prod * df['dkeff'] + df['disp10']
df['dih2'] = (1-tax) * prod * df['dkeff'] + df['disp2']


# asset reconstruction
# optimal recovery rate
df['reco_rate'] = df.apply(optimize_reco, axis=1)

# recovery time in years
df['reco_time'] = np.log(1/0.05) / df['reco_rate']

# reconstruction costs to household consumption
# example for a single hh dkeff non nan
index = df['keff'].first_valid_index()

# TODO: read the financial dataframe and add savings to this dataframe
dc, t = cons_change(df['dih10'].iloc[int(index)].item(), df['dkeff'].iloc[int(index)].item(), df['reco_rate'].iloc[int(index)].item())

gamma = floor(df['keff'].iloc[int(index)].item(), df['v'].iloc[int(index)].item(), df['reco_rate'].iloc[int(index)].item())
print(gamma)
# ----------------- plotting -----------------
##
print(f'Min: {df_hh.ym_especie.min()}')
print(f'Max: {df_hh.ym_especie.max()}')
print(f'Mean: {df_hh.ym_especie.mean()}')
print(f'Median: {df_hh.ym_especie.median()}')

# TODO: plot ym_especie to see the distribution perhaps per month to compare with income data
# ih and dih
fig, ax = plt.subplots(1, figsize=(7, 5))
sns.histplot(data=df_hh[['ym_especie']])
# sns.histplot(data=df_hh, x='y_monetario', label='$i_h$')
ax.set_xlim(left=0)
ax.set_xlabel('Monthly hh income [Bs]')
ax.set_yscale('log')
ax.legend()
plt.savefig(os.path.join(pdir, 'Figures', 'INE', 'hh_labor_income_logscale.png'))

fig, ax = plt.subplots(1, figsize=(7, 5))
probplot(df_hh['ym_especie'], dist='norm', plot=ax)
plt.savefig(os.path.join(pdir, 'Figures', 'INE', 'hh_labor_income_QQplot.png'))


##

fig, ax = plt.subplots()
sns.histplot(data=df, x='reco_time', ax=ax)
plt.savefig(os.path.join(pdir, 'Figures', 'INE', 'processed', 'recovery_time.png'))

fig, ax = plt.subplots()
ax.plot(t, dc)
ax.axhline(y=gamma, ls='--')
plt.gca().invert_yaxis()
ax.set_xlim(left=0, right=df['reco_time'].iloc[int(index)].item()+1)
ax.set_xlabel('Time after disaster [years]')
ax.set_ylabel('Household consumption $c_h$')
ax.set_title(df['reco_time'].iloc[int(index)].item())

plt.show()