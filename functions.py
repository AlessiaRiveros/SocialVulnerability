import numpy as np


def optimize_reco(row, verbose=False):
    """
    Function adapted from Walsh & Hallegatte (2000)
    :param row:
    :param verbose:
    :return:
    """

    pi = 83541 / 170129
    rho = 12.67 / 100
    eta = 1.5

    v = row['v']
    if v == 0:
        return 0

    last_integ = None
    last_lambda = None

    _l = 0.0
    while True:

        if pi - (pi + _l) * v < 0:
            assert (False)

        x_max = 15
        dt_step = 52 * x_max

        integ = 0
        for _t in np.linspace(0, x_max, dt_step):
            integ += np.e ** (-_t * (rho + _l)) * ((pi + _l) * _t - 1) * (pi - (pi + _l) * v * np.e ** (-_l * _t)) ** (
                -eta)

        if last_integ and ((last_integ < 0 < integ) or (last_integ > 0 > integ)):
            print('\nFound the Minimum!\nlambda = ', last_lambda, '--> integ = ', last_integ)
            print('lambda = ', _l, '--> integ = ', integ)
            return (_l + last_lambda) / 2

        last_integ = integ
        last_lambda = _l
        _l += 0.01


def cons_change(dih, dkeff, l, S=0):
    x_max = 10
    dt_step = 20 * x_max
    c_reco = np.zeros(dt_step)
    c = np.zeros(dt_step)
    for i, t in enumerate(np.linspace(0, x_max, dt_step)):
        c_reco[i] = l * dkeff * np.exp(-l * t)
        c[i] = dih + c_reco[i] - S
    return c, np.linspace(0, x_max, dt_step)


def floor(keff, v, l, S=0):
    pi = 83541 / 170129
    result = np.zeros(50)
    for i, _gamma in enumerate(np.linspace(5, 50, 50)):
        beta = _gamma / (keff * v * (pi + l))
        result[i] = keff * v * (pi + l) * (1 - beta) + _gamma * np.log(beta) - l * S
    index = np.abs(result).argmin()
    gamma = np.linspace(5, 50, 50)[index]
    return gamma
