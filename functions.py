import numpy as np

# global variables
pi = 83541 / 170129
rho = 12.67 / 100
eta = 1.5


def optimize_reco(row, verbose=False):
    """
    Function adapted from Walsh & Hallegatte (2000)
    :param row:
    :param verbose:
    :return:
    """

    v = row['v']
    if v == 0:
        return 0

    last_integ = None
    last_lambda = None

    _l = 0.0
    while True:

        if pi - (pi + _l) * v < 0:
            assert (False)

        x_max = 15
        dt_step = 52 * x_max

        integ = 0
        for _t in np.linspace(0, x_max, dt_step):
            integ += np.e ** (-_t * (rho + _l)) * ((pi + _l) * _t - 1) * (pi - (pi + _l) * v * np.e ** (-_l * _t)) ** (
                -eta)

        if last_integ and ((last_integ < 0 < integ) or (last_integ > 0 > integ)):
            print('\nFound the Minimum!\nlambda = ', last_lambda, '--> integ = ', last_integ)
            print('lambda = ', _l, '--> integ = ', integ)
            return (_l + last_lambda) / 2

        last_integ = integ
        last_lambda = _l
        _l += 0.01


# def cons_change(dt_step, dih, dkeff, l, S=0):
#     x_max = 10
#     c_reco = np.zeros(dt_step)
#     c = np.zeros(dt_step)
#     for i, t in enumerate(np.linspace(0, x_max, dt_step)):
#         c_reco[i] = l * dkeff * np.exp(-l * t)
#         c[i] = dih + c_reco[i] - S
#     return c, np.linspace(0, x_max, dt_step)


# this function is okay it seems
def cons_change(dih, keff, dkeff, v, l, dt_step, s=0):
    x_max = 10
    c_reco = np.zeros(dt_step)
    dc = np.zeros(dt_step)

    for i, t in enumerate(np.linspace(0, x_max, dt_step)):
        c_reco[i] = l * dkeff * np.exp(-l * t)
        # print(f'c_reco[i]: {c_reco[i]}')
        dc[i] = dih + c_reco[i] - s
    # gamma = floor(keff, v, l, s=0)
    # dc[dc > gamma] = gamma

    return dc

def floor(keff, v, l, s=0):
    # division by 0 when gamma = 0
    result = np.zeros(50)
    for i, _gamma in enumerate(np.linspace(5, 50, 20)):
        print(keff * v * (pi + l))
        print(f'gamma: {_gamma}')
        beta = _gamma / (keff * v * (pi + l))
        print(f'beta: {beta}')
        result[i] = keff * v * (pi + l) * (1 - beta) + _gamma * np.log(beta) - l * s
    index = np.abs(result).argmin()
    gamma = np.linspace(5, 50, 50)[index]
    return gamma


def well_recons_loss(dih, keff, dkeff, v, l, s=0):
    x_max = 10
    dt_step = 52 * x_max

    dc = cons_change(dih, keff, dkeff, v, l, dt_step, s=0)
    ch0 = dc[0]
    # print(f'ch0: {ch0}')
    cst = ch0**(1-eta) / (1-eta)
    integ = 0

    # for t=0, integral is 0, gives a division by 0 otherwise, so exclude from for loop
    for i, _t in enumerate(np.linspace(0+dt_step, x_max, dt_step)):
        # print(f'i:{i}')
        # print(f'_t: {_t}')
        # print(f'dc[i]: {dc[i]}')
        print((dc[i] / ch0 * np.exp(-l * _t))**(1 - eta))
        integ += dt_step * ((1 - dc[i] / ch0 * np.exp(-l * _t))**(1 - eta) - 1) * np.exp(-rho * _t)
        print(f'integ: {integ}')

    integ = integ * cst

    return integ