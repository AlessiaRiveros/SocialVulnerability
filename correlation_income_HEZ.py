import os
import pandas as pd
import geopandas as gpd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from mpl_toolkits.axes_grid1 import make_axes_locatable
from shapely.geometry import box
from scipy import stats
import seaborn as sns

pdir = r'p:\11209200-020-sociale-kwetsbaarheid'

azone = gpd.read_file(os.path.join(pdir, 'Data', 'Income', 'AZONE.shp'))
inc = pd.read_excel(os.path.join(pdir, 'Data', 'Income', 'Income.xlsx'))
hez = gpd.read_file(os.path.join(pdir, 'Data', 'ZEH_2021', 'ZONAS_ECON_HOM.shp'))

# ----------------- configurations -----------------
# select DISTRITO or MUNICIPIO
admin_var = "DISTRITO"
vmax = 1600
vmin = 30
hez_type = "building"

# ingresos mensuales por hogar
R = np.array([1500, 3000, 5000, 7000, 9000, 11000, 13000, 14500])

# ----------------- process data -----------------
# drop columns
hez = hez.drop(columns=['OID_', 'FolderPath', 'SymbolID', 'AltMode', 'Base', 'Clamped', 'Extruded', 'Snippet', 'PopupInfo'])

# create ID based on Name Z-..
pattern = r'(\d+)'
hez['IDhez'] = hez['Name'].str.extract(pattern).astype('Int64')

# boundaries to exclude areas where FIAT results not available
xmin = -63.26
xmax = -63.05
ymin = -17.9
ymax = -17.65

bbox = box(xmin, ymin, xmax, ymax)
hez = gpd.clip(hez, mask=bbox)
# hez = hez.cx[xmin:xmax, ymin:ymax]

# add valor del pavimento asfaltado
hez_pavement = {
    1: 1978.80,
    2: 1414.81,
    3: 1113.37,
    4: 903.82,
    5: 819.46,
    6: 676.45,
    7: 453.12,
    8: 310.93,
    9: 200.08,
    10: 98.70,
    11: 70.86,
    12: 58.41,
    13: 34.00,
    14: 28.79,
    15: 23.78,
    16: 23.78,
    17: 23.78,
    18: 23.78
}
# o valor maximo de da√±os edificios residenciales?
hez_building = {
    1: 1232.28,
    2: 881.06,
    3: 693.34,
    4: 562.85,
    5: 510.31,
    6: 421.25,
    7: 282.18,
    8: 193.63,
    9: 124.60,
    10: 61.46,
    11: 44.13,
    12: 36.37,
    13: 21.17,
    14: 17.93,
    15: 14.81,
    16: 14.81,
    17: 14.81,
    18: 14.81
}

if hez_type == "pavement":
    hez_values = hez_pavement
elif hez_type == "building":
    hez_values = hez_building
else:
    print('please specify either pavement or building')
hez = hez.sort_values(by=['IDhez'])
hez["Value"] = hez.IDhez.map(hez_values)

# income per AZONE
inc['Income'] = (inc['R1'] * R[0] + inc['R2'] * R[1] + inc['R3'] * R[2] + inc['R4'] * R[3] + inc['R5'] * R[4] \
                          + inc['R6'] * R[5] + inc['R7'] * R[6] + inc['R8'] * R[7]) / inc['Total']
inc = inc.rename(columns={"AZONE": "ID"})

azone = azone.merge(inc, on='ID')

# compare azone and HEZ using union?
gdf = azone.overlay(hez, keep_geom_type=False, how='union')
# drop nan values to be able to use linear regression
gdf = gdf.dropna(subset=['Income', 'Value'])
# gdf.boundary.plot()

# convert data to numpy to compute correlation
df = pd.DataFrame(gdf)
x = gdf['Income'].to_numpy()
y = gdf['Value'].to_numpy()
z = gdf[admin_var].to_numpy()

# pearson correlation
pearson = stats.pearsonr(x, y).statistic

# spearman rank correlation
spearman = stats.spearmanr(x, y).statistic

# linear regression
lr = LinearRegression(fit_intercept=True)
lr.fit(x.reshape(-1, 1), y)

# ----------------- plotting -----------------
# plot income and values
fig, ax = plt.subplots(1, 2, figsize=(14, 8))

ax0_divider = make_axes_locatable(ax[0])
ax1_divider = make_axes_locatable(ax[1])

cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")

gdf.plot(ax=ax[0], column='Income', cax=cax0, legend=True, legend_kwds={"label": "Bs/month/household"})
gdf.plot(ax=ax[1], column='Value', cax=cax1, legend=True, vmax=vmax, vmin=vmin, legend_kwds={"label": "Bs/m$^2$"})

ax[0].title.set_text('Monthly Income per Household')
ax[1].title.set_text('Asphalt Pavement Value')
plt.tight_layout()
plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{hez_type}_Azone_income_HEZ_values.png'))

# scatter plot of income and values
fig, ax = plt.subplots(1, figsize=(12, 8))
ax.scatter(x, y)
# beta0 = {lr.intercept_:.3f}, beta1 = {lr.coef_[0]:.3f} \n
ax.plot(x, lr.intercept_+lr.coef_[0]*x, color='red', label=f'pearson={pearson:.2f} r$^2$={pearson**2:.2f}\n spearman={spearman:.2f}')
ax.set_ylabel('Values [Bs/m$^2$]')
ax.set_xlabel('Income [Bs/month/household]')
plt.legend()
plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{hez_type}_correlation.png'))

# map of districts or municipios
fig, ax = plt.subplots(1, figsize=(7, 8))
gdf.plot(ax=ax, column=admin_var, legend=True)
plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{str(admin_var).lower()}.png'))

# color code per district to see if there are clusters in the scatterplot
units = list(set(z))
cmap = plt.get_cmap('rainbow')
color_values = np.linspace(0, 1, len(units))
rgb_colors = [cmap(value)[:3] for value in color_values]
hex_colors = ['#%02x%02x%02x' % tuple(int(255 * c) for c in rgb) for rgb in rgb_colors]
color_dict = dict(zip(units, hex_colors))

# scatter plot of income and values colorcoded by district or municipios
plt.figure(figsize=(12, 8))
sns.scatterplot(x='Income', y='Value', hue=admin_var, data=df, palette=hex_colors, s=100)
plt.xlabel('Income [Bs/month/household]')
plt.ylabel('Values [Bs/m$^2$]')
plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{hez_type}_correlation_{str(admin_var).lower()}_colorcoded.png'))

plt.close()