import os
import geopandas as gpd
import pandas as pd
import tomli
from shapely.geometry import box
import pandas as pd
import numpy as np
import math
import geopandas as gpd
import matplotlib.pyplot as plt
from scipy.integrate import quad
from scipy.optimize import minimize
from IPython.display import display, Math, Latex
from shapely.geometry import shape
from shapely.wkt import loads
from scipy.optimize import root_scalar
import mapclassify
from matplotlib.colors import ListedColormap
import seaborn as sns


n = 1.5
p = 0.1267

def delta_i(t, labda, v, i_hh):
    return v * i_hh * math. e**(-labda *t)


def delta_i_plot(t, labda, v, i_hh):
    income_l = v * i_hh * math. e**(-labda *t)
    if np.all(t < np.array([0])):
        return i_hh
    else:
        return i_hh -income_l


def c_reco(t, labda, v, k_str):
    return labda * v * k_str * math. e**(-labda * t)


def c_reco_plot(t, labda, v, k_str, i_hh):
    recovery = labda * v * k_str * math. e**(-labda * t)
    if np.all(t < np.array([0])):
        return i_hh
    else:
        return i_hh -recovery


def delta_c(t, labda, v, k_str, i_hh):
    return  c_reco(t, labda, v, k_str) + delta_i(t, labda, v, i_hh)


c_negative =[]


def c_t(t, labda, v, k_str, i_hh, c_0, damage):
    c = c_0 - delta_c(t, labda, v, k_str, i_hh)

    if np.all(t < np.array([0])):
        return c_0
    elif np.all(t > np.array([0])):
        if np.all(c < np.array([0])):
            c_negative.append(c)
            return c
        else:
            return c


def u_t(t, labda, v, k_str, i_hh, c_0, damage):
    consump = c_t(t, labda, v, k_str, i_hh, c_0, damage)
    utility = (consump ** (1 - n)) / (1 - n)
    return utility


def delta_U(labda, v, k_str, i_hh, c_0, damage):
    def u(t, labda, v, k_str, i_hh, c_0, damage):
        u_0 = (c_0 ** (1 - n)) / (1 - n)
        u_time = u_t(t, labda, v, k_str, i_hh, c_0, damage)
        u_loss = (u_0 - u_time) * math.e ** (-p * t)
        return u_loss

    integral_U, error = quad(u, 0, 10, args=(labda, v, k_str, i_hh, c_0, damage))
    return integral_U


def objective_function(labda, v, k_str, i_hh, c_0, damage):
    integral_value, _ = quad(u_t, 0, 10, args=(labda, v, k_str, i_hh, c_0, damage))
    return -integral_value  # Negative since we are using a minimization function


def optimal_labda(v, k_str, i_hh, c_0, damage):
    # Initial guess for labda
    initial_labda_guess = 5 # changing from 0.3 to 0.6 and to 5 does not change the outcome

    # Minimize the negative of the objective function to find the maximum
    result = minimize(objective_function, initial_labda_guess, args=(v, k_str, i_hh, c_0, damage),
                      method='Nelder-Mead', tol=1e-6, bounds=[(0.3, 30)])  # changing from 140 to 30 does not change the outcome

    # Extract the optimal labda value
    optimal_labda = result.x[0]
    print(result.message)
    return optimal_labda


def total_delta_c(labda, v, k_str, i_hh, T):
    integral_delta_c, error = quad(delta_c, 0, T, args=(labda, v, k_str, i_hh))
    return integral_delta_c


def total_delta_i(labda, v, i_hh, T):
    integral_delta_i, error = quad(delta_i, 0, T, args=(labda, v, i_hh))
    return integral_delta_i


def total_c_reco(labda, v, k_str, T):
    integral_c_reco, error = quad(c_reco, 0, T, args=(labda, v, k_str))
    return integral_c_reco

L = []

pdir = r'p:\11210264-001-just-equitable-paths\wellbeing'
source = "asphalt_based"
data = pd.read_csv(os.path.join(pdir, 'data', '3-input', 'EW', source, 'database.csv'))
# drop rows with nan values
data = data.dropna()
# remove rows where pop = 0
data = data[data['Pop2016'] != 0]

# filter by inner ring
data = data[data['inner_ring'] == "Yes"]

# rename columns for simplicity
data = data.rename(columns={
    'IDazone': 'ID',
    'I_hh_year': 'ave_i_0',
    'TotPotDam': 'ave_k_str',
    'TD_100_RP_hh': 'ave_damage'
})
data['v'] = data['ave_damage'] / data['ave_k_str']

for index, row in data.iterrows():
    consumption = row['ave_i_0']
    v = row['v']
    k_str = row['ave_k_str']
    i_hh = row['ave_i_0']
    damage = row['ave_damage']

    results_L = optimal_labda(v, k_str, i_hh, consumption, damage)

    L.append(results_L)

L_df = pd.DataFrame(L)
print(L_df)
# => gives everywhere 0.3 for lambda!