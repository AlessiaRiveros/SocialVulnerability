import os
import geopandas as gpd
import pandas as pd
import numpy as np
import tomli
from shapely.geometry import box

pdir = r'p:\11210264-001-just-equitable-paths\wellbeing'
source = "asphalt_based"  # or income_based

# AZONE geometry
gdf = gpd.read_file(os.path.join(pdir, 'data', '1-external', 'income', 'AZONE.shp'))

# database created in EW module with the pop data, the fiat data and the income data in a single csv file
df = pd.read_csv(os.path.join(pdir, 'data', '3-input', 'EW', source, 'database.csv'))

eta = 1.5
rho = 0.1267
opt_timestep = 0.01
T = 100

# rename columns for simplicity
df = df.rename(columns={
    'IDazone': 'ID',
    'TotPotDam': 'kprv',
    f'TD_{T}_RP': 'd_kprv',
    f'TD_{T}_RP_hh': 'd_kprv_hh',
    'I_hh_year': 'aeexp'
})
df['v'] = df['d_kprv'] / df['kprv']
df['k'] = df['d_kprv_hh'] / df['v']


def optimize_reco(x):
    isBankrupt = False
    last_integ = 0.
    last_tau = 0.
    _tau = 0.

    while True:
        # _tau = lambda?
        # this seems to be c0 - delta k, also why *tau instead of exp(-tau)?
        # c0 only used to determine whether hh is bankrupt or not, not used for optimization calculation
        # c0 = x['aeexp']-x['v']*(x['k']*_tau)
        # if c0 <= extreme_poverty_line * 12:
        #     isBankrupt = True
        #     return [last_tau, isBankrupt]

        t_max = 15
        nsteps = 52 * t_max
        dt = t_max / nsteps

        integ = 0
        for _t in np.linspace(0, t_max, nsteps):
            integ += dt * np.e ** (-_t * (rho + _tau)) * (((x['k'] * x['v']) * (_tau * _t - 1))  # dc/d_tau
                                                          * (x['aeexp'] - (x['v'] * x['k'] * _tau) * np.e ** (
                            -_tau * _t)) ** (-eta))  # c^(-eta)

        #         print(last_integ, integ)
        if (last_integ < 0 < integ) or (last_integ > 0 > integ):
            return [(_tau + last_tau) / 2, isBankrupt]

        last_integ = integ
        print(last_integ)
        if last_integ is None:
            assert False

        last_tau = _tau
        _tau += opt_timestep

        # check for runaway
        if _tau > 10:
            return [last_tau, isBankrupt]


df_test = df[0:2]
df_test['opt'] = df.apply(lambda x: optimize_reco(x), axis=1)

# increases decrease always negative e-7 e-6 e-5 and then changes to nan!
