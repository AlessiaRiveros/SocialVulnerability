import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import tomli

with open("../config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# ----------------- configurations -----------------
T = snakemake.params.t
method = snakemake.params.method
building_type = "residential"
hh = config["macro"]["hh"]  # empirically!
pd.set_option('display.max_columns', None)
# boundary for the income classes "high" "med" or "low
boundary_type = 'low'
# mean monthly income per household in 2016
# I_hh_month = 4234   # INE
I_hh_month = config["income"]["JICA"]
gamma = config["macro"]["gamma"]

# ----------------- load data -----------------
tdam = pd.read_csv(snakemake.input.fiat_csv, index_col="IDazone")
inc = pd.read_csv(snakemake.input.inc_csv, index_col="ID")
pop = pd.read_csv(snakemake.input.pop_csv, index_col="IDazone")

csv_out = snakemake.output.csv

# ----------------- process data -----------------
# R income information
if boundary_type == 'low':
    R = np.array([1000, 2000, 4000, 6000, 8000, 10000, 12000, 14000]) / hh * 12  # [months/year]
elif boundary_type == 'high':
    R = np.array([1999, 3999, 5999, 7999, 9999, 11999, 13999, 14500]) / hh * 12  # [months/year]
elif boundary_type == 'med':
    R = np.array([1500, 3000, 5000, 7000, 9000, 11000, 13000, 14500]) / hh * 12  # [months/year]
else:
    print('please specify high, med, low')

print(f"T={T}, {building_type} buildings, income boundary {boundary_type}")

# create a column to distinguish between inner ring and outside
# filter dataframes to only keep inner circle
inner_ring_ids = [2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 94, 95, 96, 97, 98, 99]
inc['inner_ring'] = 'No'
inc.loc[inc.index.isin(inner_ring_ids), 'inner_ring'] = 'Yes'

# rename index
inc.index.names = ["IDazone"]

# add total damages event
inc[['TD_E', 'Buildings', 'TotPotDam', 'RelDam']] = tdam[['TD_E', 'Buildings', 'TotPotDam', 'RelDam']]
# add population
inc['Pop2016'] = pop['POP16']

# total population
totpop = pop.sum().item()
print(f"The total population considered is {round(totpop)}")

# income per capita per year per AZONE
inc['I_cap_year'] = (inc['R1'] * R[0] + inc['R2'] * R[1] + inc['R3'] * R[2] + inc['R4'] * R[3] + inc['R5'] * R[4] \
                          + inc['R6'] * R[5] + inc['R7'] * R[6] + inc['R8'] * R[7]) / inc['Total']

# drop R columns not necessary anymore
inc.drop(columns=['R1', 'R2', 'R3', 'R4', 'R5', 'R6', 'R7', 'R8'], inplace=True)
# rename 'Total' total interviewed by JICA to 'I_interviewed'
inc = inc.rename(columns={"Total": "I_interviewed"})

# income per hh per year per AZONE
inc['I_hh_year'] = inc['I_cap_year'] * hh

# income per capita per year in the whole area
inc['I_year'] = inc['I_cap_year'] * pop['POP16']
tot_I_cap_year = inc['I_year'].sum() / totpop
print(f"The income per capita per year calculated is Bs {tot_I_cap_year:.2f}")
print(f"The income per household per month calculated is Bs {tot_I_cap_year / 12 * hh:.2f}")

tot_I_cap_year = I_hh_month * 12 / hh
print(f"The income per capita per year according to INE or JICA is Bs {tot_I_cap_year:.2f}")

# equity weight
inc['EW'] = (inc['I_cap_year'] / tot_I_cap_year)**-gamma
inc['EW_TD_E'] = inc['EW'] * inc['TD_E']

# to translate fiat tot damages to per hh
inc['TD_E_hh'] = inc['TD_E'] / pop['POP16'] * hh

# difference between total damages minus EW damages
inc['diff_TD-EW'] = inc['TD_E'] - inc['EW_TD_E']
inc.to_csv(csv_out)

