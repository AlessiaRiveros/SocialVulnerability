import geopandas as gpd
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# input
pdir = r'p:\11210264-001-just-equitable-paths\wellbeing'
buildings_shp = pdir + "/data" + "/1-interim" + "/FIAT" + "/clipped_ids.shp"
exposure_csv = pdir + "/data" + "/1-interim" + "/FIAT" + "/asphalt_based" + "/exposure.csv"
azone_shp = pdir + "/data" + "/1-interim" + "/income" + "/AZONE.shp"

# output
income_out = pdir + "/data" + "/2-interim" + "/income" + "/income_dwelling.csv"
exposure_out = pdir + "/data" + "/2-interim" + "FIAT" + "/income_based" + "/exposure.csv"

# read input data
buildings_gdf = gpd.read_file(buildings_shp)
exposure_df = pd.read_csv(exposure_csv)
azone_gdf = gpd.read_file(azone_shp)

# ingresos
income_csv = pdir + "/data_cleaned/EW/10_database.csv"
income_df = pd.read_csv(income_csv)

# create dwelling dataframe: valor de vivienda por tipologia en Santa Cruz
dwelling_type = ["De Lujo", "Muy Buena", "Buena", "Economica", "Interes Social", "Marginal"]
dwelling_value = [3423, 2283, 1516, 950, 570, 96]
dwelling_df = pd.DataFrame({"Tipo de vivienda": dwelling_type, "Valor de la vivienda [Bs/m2]": dwelling_value})


def normalize(x, xmin, xmax):
    return (x - xmin) / (xmax - xmin)


# normalizar vivienda
dwelling_df["Valor normalizado"] = dwelling_df.apply(
    lambda row: normalize(row["Valor de la vivienda [Bs/m2]"],
                          dwelling_df["Valor de la vivienda [Bs/m2]"].min(),
                          dwelling_df["Valor de la vivienda [Bs/m2]"].max()),
    axis=1)


# normalizar ingresos
income_df["I_cap_year_norm"] = income_df.apply(
    lambda row: normalize(row["I_cap_year"],
                          income_df["I_cap_year"].min(),
                          income_df["I_cap_year"].max()),
    axis=1)

# sort values from 1 to 0
income_df.sort_values(by="I_cap_year_norm", ascending=False, inplace=True)
# drop nan values
income_df.dropna(subset="I_cap_year_norm", inplace=True)

# create a dwelling column to translate income values to dwelling values
income_df["dwelling"] = np.nan

# find closest value in normalized income to normalized dwelling
for dwelling_id in np.arange(0, 6):
    idx = income_df.iloc[(income_df["I_cap_year_norm"] - dwelling_df.loc[dwelling_id, "Valor normalizado"]).abs().argsort()[:1]].index.item()
    income_df.loc[idx, "dwelling"] = dwelling_df.loc[dwelling_id, "Valor de la vivienda [Bs/m2]"]

# interpolate for the rest of the dwelling values
income_df.set_index("I_cap_year_norm", inplace=True)
income_df["dwelling"] = income_df["dwelling"].interpolate(method="linear", limit_direction="both")
income_df.reset_index(inplace=True)

# incluir depreciacion y 1 - proteccion
income_df["act_dwelling"] = income_df["dwelling"] * 0.6 * (1 - 0.4) * 1

# save df
income_df = income_df[["IDazone", "I_cap_year_norm", "I_cap_year", "dwelling", "act_dwelling"]]
income_df.to_csv(income_out)

# add dwelling values to AZONE gpd based on the ID = IDazone
azone_gdf = azone_gdf.rename(columns={"ID": "IDazone"})
azone_gdf = azone_gdf.merge(income_df, on="IDazone")

# get area of objects
buildings_gdf["area"] = buildings_gdf.area

# building gdf and azone gdf crs are not the same
azone_gdf = azone_gdf.to_crs("EPSG:32720")

# find which buildings correspond to which azones
gdf = buildings_gdf.sjoin(azone_gdf, predicate="within")

# for each building id use the dwelling value [Bs/m2] x area [m2] to get the max pot damages [Bs]
gdf["maxpotdam"] = gdf["area"] * gdf["act_dwelling"]

# contents values = max structural values * 0.5 for residential buildings
gdf["content"] = gdf["maxpotdam"] * 0.5

# rename columns to match what FIAT expects
gdf = gdf.rename(columns={
    "OBJECTID": "Object ID",
    "maxpotdam": "Max Potential Damage: Structure",
    "content": "Max Potential Damage: Content"
})

# only keep columns we want to update in the exposure.csv file
gdf = gdf[["Object ID", "Max Potential Damage: Structure", "Max Potential Damage: Content"]]

# keep original column order
cols = exposure_df.columns

# drop columns we want to replace by gdf
exposure_df = exposure_df.drop(columns=["Max Potential Damage: Structure", "Max Potential Damage: Content"])

# merge exposure csv we want to update with cols we calculated in gdf
df = exposure_df.merge(gdf, on="Object ID")
df = df[cols]

# save df to csv to run FIAT again
df.to_csv(exposure_out, index=False)
