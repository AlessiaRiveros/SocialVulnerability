import os
import pandas as pd
import geopandas as gpd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from mpl_toolkits.axes_grid1 import make_axes_locatable
from shapely.geometry import box
from scipy import stats
import seaborn as sns
import tomli

with open("../config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# pdir = r'p:\11209200-020-sociale-kwetsbaarheid'
#
# azone = gpd.read_file(os.path.join(pdir, 'Data', 'Income', 'AZONE.shp'))
# inc = pd.read_excel(os.path.join(pdir, 'Data', 'Income', 'Income.xlsx'))
# hez = gpd.read_file(os.path.join(pdir, 'Data', 'ZEH_2021', 'ZONAS_ECON_HOM.shp'))
# distrito = gpd.read_file(os.path.join(pdir, 'Data', 'Population', 'INEDistritos.shp'))

azone = gpd.read_file(snakemake.input.azone_shp)
inc = pd.read_csv(snakemake.input.inc_csv)
hez = gpd.read_file(snakemake.input.hez_shp)
distrito = gpd.read_file(snakemake.input.districts_shp)

csv_out = snakemake.output.inc_csv
# figure_names
fig_inc_hez = snakemake.output.inc_hez_png
fig_scatterplot = snakemake.output.scatterplot_png
fig_histogram = snakemake.output.histogram_png
fig_districts = snakemake.output.districts_png
fig_scatterplot_color = snakemake.output.scatterplot_color_png
fig_heatmap = snakemake.output.heatmap_png
fig_outliers = snakemake.output.outliers_png


# ----------------- configurations -----------------
# select DISTRITO or MUNICIPIO
admin_var = "DISTRITO"
# building or pavement for the value associated to each HEZ
hez_type = "pavement"
# for the scatterplot either Income or Value
x_var = "Value"

# ingresos mensuales por hogar
R = np.array([1000, 2000, 4000, 6000, 8000, 10000, 12000, 14000])
pd.set_option('display.max_columns', None)
# ----------------- process data -----------------
# drop columns
hez = hez.drop(columns=['OID_', 'FolderPath', 'SymbolID', 'AltMode', 'Base', 'Clamped', 'Extruded', 'Snippet', 'PopupInfo'])

# create ID based on Name Z-..
pattern = r'(\d+)'
hez['IDhez'] = hez['Name'].str.extract(pattern).astype('Int64')

# boundaries to exclude areas where FIAT results not available
xmin = config['bbox']['xmin']
xmax = config['bbox']['xmax']
ymin = config['bbox']['ymin']
ymax = config['bbox']['ymax']

bbox = box(xmin, ymin, xmax, ymax)
print(f'before clipping to bbox: {len(hez)} HEZ and {len(azone)} AZONE')
hez = gpd.clip(hez, mask=bbox)
azone = gpd.clip(azone, mask=bbox)
print(f'after clipping to bbox: {len(hez)} HEZ and {len(azone)} AZONE')

distrito = distrito.to_crs(crs='EPSG:4326')
distrito = gpd.clip(distrito, mask=bbox)
# exclude viru viru y urbo
mask = (distrito['DISTRITO'] == 'Viru Viru') | (distrito['DISTRITO'] == 'Urbo') | (distrito['DISTRITO'] == 'Distrito 4')\
       | (distrito['DISTRITO'] == 'Lomas Arenas') | (distrito['DISTRITO'] == 'Las Gamas')
distrito = distrito.loc[~mask]

# hez = hez.cx[xmin:xmax, ymin:ymax]

# add valor del pavimento asfaltado
hez_pavement = {
    1: 1978.80,
    2: 1414.81,
    3: 1113.37,
    4: 903.82,
    5: 819.46,
    6: 676.45,
    7: 453.12,
    8: 310.93,
    9: 200.08,
    10: 98.70,
    11: 70.86,
    12: 58.41,
    13: 34.00,
    14: 28.79,
    15: 23.78,
    16: 23.78,
    17: 23.78,
    18: 23.78
}
# o valor maximo de da√±os edificios residenciales?
hez_building = {
    1: 1232.28,
    2: 881.06,
    3: 693.34,
    4: 562.85,
    5: 510.31,
    6: 421.25,
    7: 282.18,
    8: 193.63,
    9: 124.60,
    10: 61.46,
    11: 44.13,
    12: 36.37,
    13: 21.17,
    14: 17.93,
    15: 14.81,
    16: 14.81,
    17: 14.81,
    18: 14.81
}

if hez_type == "pavement":
    hez_values = hez_pavement
    vmax = 1600
    vmin = 30
    title = 'Asphalt Pavement Value'
elif hez_type == "building":
    vmax = 1000
    vmin = 30
    hez_values = hez_building
    title = 'Max Damages Residential Buildings'
else:
    print('please specify either pavement or building')

hez = hez.sort_values(by=['IDhez'])
hez["Value"] = hez.IDhez.map(hez_values)

# income per AZONE, income per hh
inc['Income'] = (inc['R1'] * R[0] + inc['R2'] * R[1] + inc['R3'] * R[2] + inc['R4'] * R[3] + inc['R5'] * R[4] \
                          + inc['R6'] * R[5] + inc['R7'] * R[6] + inc['R8'] * R[7]) / inc['Total']
inc = inc.rename(columns={"AZONE": "ID"})
# inc.to_csv(os.path.join(pdir, 'Data', 'Income', 'AZONE_income.csv'))
inc.to_csv(csv_out, index=False)

print('Income statistics:')
print(f'Min: {inc.Income.min()}')
print(f'Max: {inc.Income.max()}')
print(f'Mean: {inc.Income.mean()}')
print(f'Median: {inc.Income.median()}')

azone = azone.merge(inc, on='ID')

# compare azone and HEZ using union?
gdf = azone.overlay(hez, keep_geom_type=False, how='union')
# drop nan values to be able to use linear regression
gdf = gdf.dropna(subset=['Income', 'Value'])
# gdf.boundary.plot()

# format admin variables
gdf['DISTRITO'] = gdf['DISTRITO'].replace("Distrito 2", "Distrito 02")
gdf['DISTRITO'] = gdf['DISTRITO'].replace("Distrito 3", "Distrito 03")
gdf['DISTRITO'] = gdf['DISTRITO'].replace("Distrito 7", "Distrito 07")
gdf = gdf.sort_values(by=['DISTRITO'])
gdf['MUNICIPIO'] = gdf['MUNICIPIO'].astype(int)

# convert data to numpy to compute correlation
df = pd.DataFrame(gdf)
if x_var == 'Income':
    y_var = 'Value'
    xlabel = 'Income [Bs/month/household]'
    ylabel = f'{title} [Bs/m$^2$]'
elif x_var == 'Value':
    y_var = 'Income'
    ylabel = 'Income [Bs/month/household]'
    xlabel = f'{title} [Bs/m$^2$]'

x = gdf[x_var].to_numpy()
y = gdf[y_var].to_numpy()
z = gdf[admin_var].to_numpy()

# spearman rank correlation
spearman = stats.spearmanr(x, y).statistic

# linear regression
lr = LinearRegression(fit_intercept=True)
lr.fit(x.reshape(-1, 1), y)

# group x,y pairs into three categories: high, medium and low
x_int = (x.max() - x.min()) / 3
y_int = (y.max() - y.min()) / 3

x_thr_low = round(x_int + x.min())
x_thr_high = round(x_int * 2 + x.min())
y_thr_low = round(y_int + y.min())
y_thr_high = round(y_int * 2 + y.min())

df[f'{x_var}_category'] = pd.cut(df[x_var], bins=[x.min(), x_thr_low, x_thr_high, x.max()], labels=['low', 'medium', 'high'])
df[f'{y_var}_category'] = pd.cut(df[y_var], bins=[y.min(), y_thr_low, y_thr_high, y.max()], labels=['low', 'medium', 'high'])

# matrix with x and y labels and values representing counts
combination_counts = df.groupby([f'{y_var}_category', f'{x_var}_category']).size().unstack(fill_value=0)
print(combination_counts)

print(f'the intervals for {x_var} are: {round(x.min())}, {x_thr_low}, {x_thr_high}, and {round(x.max())}')
print(f'the intervals for {y_var} are: {round(y.min())}, {y_thr_low}, {y_thr_high}, and {round(y.max())}')

# use matrix to find outliers: low value and high income, 51 features, where are they on the map?
df_outliers = df[(df['Income_category'] == 'high') & (df['Value_category'] == 'low')]
df_outliers.loc[:, 'Outlier'] = 1

# to which districts and HEZ?
# name or IDhez?

gdf_outliers = pd.merge(gdf, df_outliers['Outlier'], left_index=True, right_index=True, how='left')
gdf_outliers['Outlier'] = gdf_outliers['Outlier'].fillna(0).astype(int)
gdf_outliers['color'] = 'tab:blue'
gdf_outliers['color'].loc[gdf_outliers['Outlier'] == 1] = 'tab:red'
print(gdf_outliers)

# ----------------- plotting -----------------
cmap = 'RdBu'
# plot income and values side by side
fig, ax = plt.subplots(1, 2, figsize=(14, 8))

ax0_divider = make_axes_locatable(ax[0])
ax1_divider = make_axes_locatable(ax[1])

cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")

gdf.plot(
    ax=ax[0],
    column='Income',
    cax=cax0,
    cmap=cmap,
    legend=True,
    legend_kwds={"label": "Bs/month/household"}
)
gdf.plot(
    ax=ax[1],
    column='Value',
    cax=cax1,
    cmap=cmap,
    legend=True,
    vmax=vmax,
    vmin=vmin,
    legend_kwds={"label": "Bs/m$^2$"}
)

ax[0].title.set_text('Monthly Income per Household')
ax[1].title.set_text(title)

ax[0].axis("off")
ax[1].axis("off")

plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{hez_type}_Azone_income_HEZ_values.png'))
plt.savefig(fig_inc_hez)

# scatter plot of income and values
fig, ax = plt.subplots(1, figsize=(12, 8))
ax.scatter(x, y)
# beta0 = {lr.intercept_:.3f}, beta1 = {lr.coef_[0]:.3f} \n
ax.plot(x, lr.intercept_+lr.coef_[0]*x, color='red', label=f'spearman={spearman:.2f}')
ax.set_ylabel(ylabel)
ax.set_xlabel(xlabel)
plt.legend()
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{hez_type}_correlation.png'))
plt.savefig(fig_scatterplot)

# histogram of income
fig, ax = plt.subplots(1, figsize=(7, 5))
sns.histplot(data=inc['Income'], ax=ax)
ax.set_xlabel('Monthly hh labor income')
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'income_histogram.png'))
plt.savefig(fig_histogram)

# color code per district to see if there are clusters in the scatterplot
units = list(set(z))
cmap = plt.get_cmap('rainbow')
color_values = np.linspace(0, 1, len(units))
rgb_colors = [cmap(value)[:3] for value in color_values]
hex_colors = ['#%02x%02x%02x' % tuple(int(255 * c) for c in rgb) for rgb in rgb_colors]
color_dict = dict(zip(units, hex_colors))

# add color column to gdf?
gdf['color'] = gdf['DISTRITO'].map(color_dict)

# map of districts
fig, ax = plt.subplots(1, figsize=(8, 7))
ax.set_axis_off()
gdf.plot(ax=ax, legend=True, color=gdf['color'])
# gdf.plot(ax=ax, column='DISTRITO', legend=True, cmap=hex_colors)
# leg = ax.get_legend()
# leg.set_bbox_to_anchor((-0.15, 0.85, 0.2, 0.2))
plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', 'Distritos.png'))
plt.savefig(fig_districts)

# scatter plot of income and values colorcoded by district or municipios
plt.figure(figsize=(12, 8))
sns.scatterplot(x=x_var, y=y_var, hue=admin_var, data=df, palette=hex_colors, s=100, zorder=3)
plt.axhline(y=y_thr_high, color='k', alpha=0.5)
plt.axhline(y=y_thr_low, color='k', alpha=0.5)

plt.axvline(x=x_thr_high, color='k', alpha=0.5)
plt.axvline(x=x_thr_low, color='k', alpha=0.5)

plt.xlabel(xlabel)
plt.ylabel(ylabel)
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'{hez_type}_correlation_{str(admin_var).lower()}_colorcoded.png'))
plt.savefig(fig_scatterplot_color)

# heatmap of correlation grouped into categories
categories = ['low', 'medium', 'high']
plt.figure(figsize=(7, 6))
sns.heatmap(combination_counts, annot=True, fmt="d", cmap='YlGnBu', xticklabels=categories, yticklabels=categories,
            cbar_kws={'label': 'Number of Areas'})
plt.gca().invert_yaxis()
plt.xlabel(xlabel)
plt.ylabel(ylabel)
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'correlation_heatmap.png'))
plt.savefig(fig_heatmap)

# map of areas with correlation outliers
fig, ax = plt.subplots(1, figsize=(8, 6))
# gdf_outliers.loc[gdf_outliers['Outlier'] == 0] = np.nan
gdf_outliers.boundary.plot(ax=ax, color='w', lw=0.2)
gdf_outliers.plot(ax=ax, color=gdf_outliers['color'])
ax.set_axis_off()
plt.title('Outliers')
plt.tight_layout()
# plt.savefig(os.path.join(pdir, 'Figures', 'Socioeconomics', f'outliers.png'))
plt.savefig(fig_outliers)
# plt.show()
# plt.close()