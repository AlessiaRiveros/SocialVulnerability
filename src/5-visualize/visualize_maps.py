import matplotlib.pyplot as plt
import geopandas as gpd
import pandas as pd
from mpl_toolkits.axes_grid1 import make_axes_locatable
from shapely.geometry import box
import seaborn as sns
import tomli

# ----------------- configurations -----------------
# TODO: modify df when method is average is it different when dividing after having computed the EW? or should I do
#  it before?
with open("../config.toml", mode="rb") as fp:
    config = tomli.load(fp)
pd.set_option('display.max_columns', None)

# load input files
azone = gpd.read_file(snakemake.input.azone_shp)
ew = pd.read_csv(snakemake.input.ew_csv, index_col="IDazone")

# load parameters
extent = snakemake.params.extent
method = snakemake.params.method
T = snakemake.params.t

# output fig names
fig_maps = snakemake.output.maps_png
fig_barchart = snakemake.output.barchart_png


# ----------------- preprocessing -----------------

# rename column id
azone = azone.rename(columns={"ID": "IDazone"})
# set index here because not available when reading the shp
azone = azone.set_index('IDazone')

# merge gdf with df
azone[["TD_E", "EW_TD_E", "diff_TD-EW", "inner_ring"]] = ew[["TD_E", "EW_TD_E", "diff_TD-EW", "inner_ring"]]

# extent
if extent == "inner_ring":
    azone = azone[azone['inner_ring'] == 'Yes']

# mask where EW is not nan to facilitate comparison
azone = azone[azone[f'EW_TD_E'].notnull()]

# boundaries to exclude areas where FIAT results not available
xmin = config['bbox']['xmin']
xmax = config['bbox']['xmax']
ymin = config['bbox']['ymin']
ymax = config['bbox']['ymax']

bbox = box(xmin, ymin, xmax, ymax)
azone = gpd.clip(azone, mask=bbox)
print(f'There are {len(azone)} AZONES considered')

# convert to dataframe to sum rows
df = pd.DataFrame(azone[['TD_E', f'EW_TD_E']])
df = df.sum()

# ----------------- plotting -----------------

if method == "average":
    label = 'Bs/building'
elif method == "total":
    label = 'Bs/AZONE'
else:
    print("specify average or total")

vmax1 = min(azone['TD_E'].max(), azone['EW_TD_E'].max()) * 0.7
vmax2 = azone["diff_TD-EW"].abs().max() * 0.7
vmin2 = -vmax2

# plot in a 1 by 3 the total (average) residential damages, the difference between the EW and the bar chart
fig, ax = plt.subplots(1, 3, figsize=(12, 4))

ax0_divider = make_axes_locatable(ax[0])
ax1_divider = make_axes_locatable(ax[1])
ax2_divider = make_axes_locatable(ax[2])

cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")
cax2 = ax2_divider.append_axes("right", size="5%", pad="1%")

azone.plot(column='TD_E', ax=ax[0], cax=cax0, cmap='OrRd', vmax=vmax1, legend=True, legend_kwds={"label": label})
azone.plot(column='EW_TD_E', ax=ax[1], cax=cax1, cmap='OrRd', vmax=vmax1, legend=True, legend_kwds={"label": label})
azone.plot(column='diff_TD-EW', ax=ax[2], cax=cax2, cmap='bwr_r', vmin=vmin2, vmax=vmax2, legend=True, legend_kwds={"label": "Bs"})
# sns.barplot(x=df.index, y=df.values, ax=ax[2])

ax[0].title.set_text('Residential Damages')
ax[1].title.set_text('EW Residential Damages')
ax[2].title.set_text('TD Event - EW')

ax[0].set_axis_off()
ax[1].set_axis_off()
ax[2].set_axis_off()
# ax[2].title.set_text(f'Sum of {method} Residential Damages')

fig.suptitle(f'T={T} {method} of Residential Building Damages')
plt.tight_layout()
plt.savefig(fig_maps)

# bar chart of total
plt.figure(figsize=(3, 4))
sns.barplot(x=df.index, y=df.values)
plt.title(f'Sum of {method} Residential Building Damages')
plt.ylabel('Bs')
plt.tight_layout()
plt.savefig(fig_barchart)
plt.show()