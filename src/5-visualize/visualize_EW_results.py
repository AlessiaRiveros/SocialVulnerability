import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import geopandas as gpd
from shapely.geometry import box
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numpy as np
import cartopy.crs as ccrs
import cartopy.io.img_tiles as cimgt
import contextily as cx
import tomli
import matplotlib.colors as colors


with open("../config.toml", mode="rb") as fp:
    config = tomli.load(fp)

# ----------------- configurations -----------------

T1 = 50
T2 = 100

method = snakemake.params.method

fig_heatmap_T1 = snakemake.output.heatmap_T1
fig_heatmap_T2 = snakemake.output.heatmap_T2
fig_heatmap_quantiles_T1 = snakemake.output.heatmap_quantile_T1
fig_heatmap_quantiles_T2 = snakemake.output.heatmap_quantile_T2
fig_map_T1 = snakemake.output.map_T1
fig_map_T2 = snakemake.output.map_T2
fig_map_inc = snakemake.output.map_inc
fig_diff_T1 = snakemake.output.diff_T1
fig_diff_T2 = snakemake.output.diff_T2

# ----------------- load data -----------------
df = pd.read_csv(snakemake.input.ew_csv)
gdf = gpd.read_file(snakemake.input.azone_shp)

pdir = r'p:\11210264-001-just-equitable-paths\wellbeing'
shp = pdir + "/data" + "/1-external" + "/income" + "/AZONE.shp"
csv = pdir + "/data" + "/3-input" + "/EW" + "/asphalt_based" + f"/database.csv"


df = pd.read_csv(csv)
gdf = gpd.read_file(shp)

c_mean = config['income']['innerring'] * 12 / config['macro']['hh']

# ----------------- process data -----------------

# df.index = df['IDazone']
# df = df.drop(columns='IDazone')

# extent
fs = 10

df = df[['IDazone', 'I_cap_year', f'SD_{T1}_RP', f'EW_SD_{T1}_RP', f'SD_{T2}_RP', f'EW_SD_{T2}_RP',
         f'diff_SD-EW_{T1}_RP', f'diff_SD-EW_{T2}_RP']]
df = df.dropna(subset=[f'SD_{T1}_RP', f'EW_SD_{T1}_RP', f'SD_{T2}_RP', f'EW_SD_{T2}_RP'])
df = df.rename(columns={"IDazone": "ID"})


def quantiles(df):
    q1 = df.quantile(0.25)
    q2 = df.quantile(0.50)
    q3 = df.quantile(0.75)
    return q1, q2, q3


inc_q = quantiles(df['I_cap_year'])
bins = [0, inc_q[0], inc_q[1], inc_q[2], df['I_cap_year'].max()]
inc_cat = ['low_incomes', 'mid_low_incomes', 'mid_high_incomes', 'high_incomes']
df['category'] = pd.cut(df['I_cap_year'], bins=bins, labels=inc_cat)
df_cat = df.groupby(df['category']).mean()
# df_cat.drop(columns=['I_cap_year'], inplace=True)


def policy_ranking(df, T):
    df[f'rank_asset_loss_T{T}'] = df[f'SD_{T}_RP'].rank(ascending=False).astype(int)
    df[f'rank_EW_loss_T{T}'] = df[f'EW_SD_{T}_RP'].rank(ascending=False).astype(int)
    return df


# rank areas according to policy preference
policy_ranking(df, T1)
policy_ranking(df, T2)
policy_ranking(df_cat, T1)
policy_ranking(df_cat, T2)


gdf = gdf.merge(df, on='ID')

# ----------------- plotting -----------------

inc_cat_names = ['Lowest incomes', 'Mid-low incomes', 'Mid-high incomes', 'Highest incomes']


def format_func(value, _):
    # Convert the value into a formatted string with spacing
    return "{:,.0f}".format(value)


# plot per capita income and corresponding qualitative bin
fig, ax = plt.subplots(figsize=(7, 5))
ax_divider = make_axes_locatable(ax)
cax = ax_divider.append_axes("right", size="5%", pad="1%")
norm = None
format = format_func
cmap = 'RdBu'
# normalize data
min_val = gdf['I_cap_year'].min()
max_val = gdf['I_cap_year'].max()
norm = colors.TwoSlopeNorm(vcenter=c_mean, vmin=min_val, vmax=max_val)
gdf.plot(
        column='I_cap_year',
        ax=ax,
        cax=cax,
        cmap=cmap,
        norm=norm,
        legend=True,
        legend_kwds={
            "label": 'Income (Bs/yr/cap)',
            'format': format
        })
ax.set_axis_off()
plt.tight_layout()
plt.savefig(fig_map_inc)


def plot_diff(gdf, T):

    vmax = min(gdf[f'SD_{T}_RP'].max(), gdf[f'EW_SD_{T}_RP'].max())
    vmax2 = gdf[f'diff_SD-EW_{T}_RP'].abs().max() * 0.7
    label = '(Bs)'
    cmap = 'RdBu_r'

    fig, ax = plt.subplots(1, 3, figsize=(12, 4))

    ax0_divider = make_axes_locatable(ax[0])
    ax1_divider = make_axes_locatable(ax[1])
    ax2_divider = make_axes_locatable(ax[2])

    cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
    cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")
    cax2 = ax2_divider.append_axes("right", size="5%", pad="1%")

    gdf.plot(column=f'SD_{T}_RP', ax=ax[0], cax=cax0, cmap=cmap, vmax=vmax, legend=True, legend_kwds={"label": label})
    gdf.plot(column=f'EW_SD_{T}_RP', ax=ax[1], cax=cax1, cmap=cmap, vmax=vmax, legend=True, legend_kwds={"label": label})
    gdf.plot(column=f'diff_SD-EW_{T}_RP', ax=ax[2], cax=cax2, cmap='RdBu', vmin=-vmax2, vmax=vmax2, legend=True, legend_kwds={"label": label})

    ax[0].title.set_text('Asset losses')
    ax[1].title.set_text('EW losses')
    ax[2].title.set_text('Asset losses - EW losses')

    ax[0].set_axis_off()
    ax[1].set_axis_off()
    ax[2].set_axis_off()

    plt.tight_layout()

    return


plot_diff(gdf, T1)
plt.savefig(fig_diff_T1)
plot_diff(gdf, T2)
plt.savefig(fig_diff_T2)


def plot_heatmap(df, T, cat_labels=inc_cat_names):
    df = df.sort_values(by=f'rank_asset_loss_T{T}')
    fig, ax = plt.subplots(figsize=(5, len(df)/2))

    df_plot = df.copy()
    df_plot.rename(columns={f'rank_asset_loss_T{T}': 'Asset Losses',
                            f'rank_EW_loss_T{T}': 'EW Losses'},
                   inplace=True)
    if df_plot.index.name == 'category':
        # replace labels by string to show on map
        df_plot.index = df_plot.index.rename_categories(cat_labels)

    sns.heatmap(df_plot[['Asset Losses', 'EW Losses']], ax=ax, annot=True)
    ax.set_title(f'Policy preference ranking for T={T} event')
    plt.tight_layout()


plot_heatmap(df, T1)
plt.savefig(fig_heatmap_T1)
plot_heatmap(df, T2)
plt.savefig(fig_heatmap_T2)
plot_heatmap(df_cat, T1)
plt.savefig(fig_heatmap_quantiles_T1)
plot_heatmap(df_cat, T2)
plt.savefig(fig_heatmap_quantiles_T2)


def plot_ranking_location(gdf, T):
    # plot location on map of these areas
    fig, ax = plt.subplots(1, 2, figsize=(10, 6))

    ax0_divider = make_axes_locatable(ax[0])
    ax1_divider = make_axes_locatable(ax[1])

    cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
    cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")

    print(gdf.crs)

    gdf.boundary.plot(ax=ax[0], color='black', lw=0.8)
    gdf.sort_values(by=[f'rank_asset_loss_T{T}'])[0:10].plot(
        column=f'rank_asset_loss_T{T}',
        ax=ax[0],
        cax=cax0,
        cmap='rocket',
        legend=True,
        legend_kwds={"label": "Top 10 priority areas"})

    gdf.boundary.plot(ax=ax[1], color='black', lw=0.8)
    gdf.sort_values(by=[f'rank_asset_loss_T{T}'])[0:10].plot(
        column=f'rank_EW_loss_T{T}',
        ax=ax[1],
        cax=cax1,
        cmap='rocket',
        legend=True,
        legend_kwds={"label": "Top 10 priority areas"})

    # add labels
    for x, y, label in zip(gdf.geometry.representative_point().x, gdf.geometry.representative_point().y,
                           gdf['ID']):
        ax[0].text(x, y, label, fontsize=fs, ha='right', va='bottom', color='white', fontweight='bold')

    for x, y, label in zip(gdf.geometry.representative_point().x, gdf.geometry.representative_point().y,
                           gdf['ID']):
        ax[1].text(x, y, label, fontsize=fs, ha='right', va='bottom', color='white', fontweight='bold')

    ax[0].title.set_text('Asset Losses')
    ax[1].title.set_text('EW Asset Losses')

    ax[0].set_axis_off()
    ax[1].set_axis_off()

    plt.tight_layout()


plot_ranking_location(gdf, T1)
plt.savefig(fig_map_T1)
plot_ranking_location(gdf, T2)
plt.savefig(fig_map_T2)

plt.show()
