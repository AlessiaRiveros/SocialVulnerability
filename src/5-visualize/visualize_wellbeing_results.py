import os
import geopandas as gpd
import pandas as pd
import tomli
from shapely.geometry import box
import matplotlib.pyplot as plt
import seaborn as sns
from mpl_toolkits.axes_grid1 import make_axes_locatable


pdir = r'p:\11210264-001-just-equitable-paths\wellbeing'

T1 = 50
T2 = 100

# wellbeing model outputs for T=50 and T=100
csv_T1 = os.path.join(pdir, 'data', '4-output', f'database_T{T1}.csv')
csv_T2 = os.path.join(pdir, 'data', '4-output', f'database_T{T2}.csv')

source = "asphalt_based"

# AZONE geometry
gdf = gpd.read_file(os.path.join(pdir, 'data', '1-external', 'income', 'AZONE.shp'))

fig_tau = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T1}_T{T2}_tau.png")
fig_losses = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T1}_T{T2}_losses.png")
fig_heatmap_T1 = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T1}", f"T{T1}_heatmap.png")
fig_heatmap_T2 = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T2}", f"T{T2}_heatmap.png")
fig_heatmap_quantiles_T1 = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T1}", f"T{T1}_heatmap_quantiles.png")
fig_heatmap_quantiles_T2 = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T2}", f"T{T2}_heatmap_quantiles.png")
fig_quantiles = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"income_quantiles.png")
fig_priorities_T1 = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T1}", f"T{T1}_priorities.png")
fig_priorities_T2 = os.path.join(pdir, 'reports', 'figures', 'wellbeing', source, f"T{T2}", f"T{T2}_priorities.png")

# ----------------- process data -----------------

# read model output for T=50
df1 = pd.read_csv(csv_T1)
df1 = df1.dropna()
df1.set_index("ID", inplace=True, drop=True)
df1['Ceq'] = df1['Ceq'] * -1
df1 = df1[['I_hh_year', 'tau', 'd_kprv_hh', 'Ceq', f'EW_SD_{T1}_RP_hh']]
df1.rename(columns={
    'd_kprv_hh': f'asset_loss_T{T1}',
    'Ceq': f'Ceq_loss_T{T1}',
    f'EW_SD_{T1}_RP_hh': f'EW_loss_T{T1}'
}, inplace=True)


# read model output for T=100
df2 = pd.read_csv(csv_T2)
df2 = df2.dropna()
df2.set_index("ID", inplace=True, drop=True)
df2['Ceq'] = df2['Ceq'] * -1
df2 = df2[['I_hh_year', 'tau', 'd_kprv_hh', 'Ceq', f'EW_SD_{T2}_RP_hh']]
df2.rename(columns={
    'd_kprv_hh': f'asset_loss_T{T2}',
    'Ceq': f'Ceq_loss_T{T2}',
    f'EW_SD_{T2}_RP_hh': f'EW_loss_T{T2}'
}, inplace=True)

# merge housing asset losses, wellbeing losses and ew losses (everything is at hh level) from both events

# heatmap ranking

# group df by income quantiles


def quantiles(df):
    q1 = df.quantile(0.25)
    q2 = df.quantile(0.50)
    q3 = df.quantile(0.75)
    return q1, q2, q3


inc_q = quantiles(df1['I_hh_year'])
bins = [0, inc_q[0], inc_q[1], inc_q[2], df1['I_hh_year'].max()]
# note: int, otherwise minimum value is excluded!
inc_cat = ['low_incomes', 'mid_low_incomes', 'mid_high_incomes', 'high_incomes']

df1['category'] = pd.cut(df1['I_hh_year'], bins=bins, labels=inc_cat)
df1_cat = df1.groupby(df1['category']).mean()
df1_cat.drop(columns=['I_hh_year'], inplace=True)

df2['category'] = pd.cut(df2['I_hh_year'], bins=bins, labels=inc_cat)
df2_cat = df2.groupby(df2['category']).mean()
df2_cat.drop(columns=['I_hh_year'], inplace=True)

# merge both dataframes
df = pd.merge(
    df1_cat,
    df2_cat,
    how='inner',
    on='category'
)

df = df.drop(columns=['tau_x', 'tau_y'])


def policy_ranking(df, T):
    df[f'rank_asset_loss_T{T}'] = df[f'asset_loss_T{T}'].rank(ascending=False).astype(int)
    df[f'rank_Ceq_loss_T{T}'] = df[f'Ceq_loss_T{T}'].rank(ascending=False).astype(int)
    df[f'rank_EW_loss_T{T}'] = df[f'EW_loss_T{T}'].rank(ascending=False).astype(int)
    return df


# rank areas according to policy preference
policy_ranking(df, T1)
policy_ranking(df, T2)
policy_ranking(df1, T1)
policy_ranking(df2, T2)


gdf = gdf.merge(df1, on='ID')

# ----------------- plotting -----------------

# (1) plot azone with ids
fig, ax = plt.subplots()
gdf.boundary.plot(ax=ax)
for i, label in enumerate(gdf.ID):
    ax.text(
        gdf.iloc[i].geometry.centroid.x,
        gdf.iloc[i].geometry.centroid.y,
        label
    )
ax.set_axis_off()
plt.tight_layout()

# (2) plot optimal recovery time for both events
fig, ax = plt.subplots()

tau_avg1 = df1['tau'].mean()*12
tau_avg2 = df2['tau'].mean()*12

color_tau1 = 'tab:blue'
color_tau2 = 'tab:red'
binwidth = 0.3
ymax = 8

sns.histplot(data=df1['tau']*12, ax=ax, color=color_tau1, edgecolor=color_tau1, binwidth=binwidth, label=f'T={T1}')
sns.histplot(data=df2['tau']*12, ax=ax, color=color_tau2, edgecolor=color_tau2, binwidth=binwidth, label=f'T={T2}')

kwargs = {"color": color_tau1, "linewidth": 1.2}
ax.vlines(x=tau_avg1, ymin=0, ymax=ymax, **kwargs)

kwargs = {"color": color_tau2, "linewidth": 1.2}
ax.vlines(x=tau_avg2, ymin=0, ymax=ymax-1, **kwargs)

# add average tau
ax.text(tau_avg1, ymax, r"$\tau_{avg}$" + f" = {tau_avg1:.1f}", ha="left", va="top", color=color_tau1, zorder=10)
ax.text(tau_avg2, ymax-1, r"$\tau_{avg}$" + f" = {tau_avg2:.1f}", ha="left", va="top", color=color_tau2, zorder=10)

ax.set_xlabel(r"Optimal recovery time $\tau$ (months)")
ax.legend()
plt.tight_layout()
plt.savefig(fig_tau)


# (2) plot bar chart grouped into quantiles for both events
fig, ax = plt.subplots(figsize=(10, 6))

# plotting configurations
categories = ['Lowest\nincomes', 'Mid-low\nincomes', 'Mid-high\nincomes', 'Highest\nincomes']
colors = ['slategray', 'slategray', 'darkorange', 'darkorange', 'yellowgreen', 'yellowgreen']
edgecolors = ['slategray', 'darkslategray', 'darkorange', 'saddlebrown', 'yellowgreen', 'olivedrab']
hatches = [None, '////', None, '////', None, '////']

# bar chart
bars = df[[f'asset_loss_T{T1}', f'asset_loss_T{T2}', f'Ceq_loss_T{T1}', f'Ceq_loss_T{T2}', f'EW_loss_T{T1}', f'EW_loss_T{T2}']].plot(
    ax=ax,
    kind="bar",
    stacked=False,
    color=colors,
)

# hatches for one of the events only
for bars_container, hatch, edgecolor in zip(bars.containers, hatches, edgecolors):
    for bar in bars_container:
        bar.set_hatch(hatch)
        bar.set_edgecolor(edgecolor)

# legend
handles, labels = ax.get_legend_handles_labels()
custom_handles = [handles[i] for i in [0, 2, 4]]
custom_labels = ["Asset Loss", "Well-being Loss", "Equity Weighted Loss"]
ax.legend(custom_handles, custom_labels)

ax.set_xticks(range(len(categories)), categories, rotation=0)
ax.set_ylabel("Losses (Bs/hh)")
ax.set_xlabel(" ")
ax.grid(True)
plt.tight_layout()
plt.savefig(fig_losses)

inc_cat_names = ['Lowest incomes', 'Mid-low incomes', 'Mid-high incomes', 'Highest incomes']

# (3) plot heatmap for all policy types


def plot_heatmap(df, T, cat_labels=inc_cat_names):
    df = df.sort_values(by=f'rank_asset_loss_T{T}')
    fig, ax = plt.subplots(figsize=(8, len(df)/2))

    df_plot = df.copy()
    df_plot.rename(columns={f'rank_asset_loss_T{T}': 'Asset Losses',
                            f'rank_Ceq_loss_T{T}': 'Wellbeing Losses',
                            f'rank_EW_loss_T{T}': 'EW Losses'},
                   inplace=True)
    if df_plot.index.name == 'category':
        # replace labels by string to show on map
        df_plot.index = df_plot.index.rename_categories(cat_labels)

    sns.heatmap(df_plot[['Asset Losses', 'Wellbeing Losses', 'EW Losses']], ax=ax, annot=True)
    ax.set_title(f'Policy preference ranking for T={T} event')
    plt.tight_layout()


# grouped into income quantile
plot_heatmap(df, T1)
plt.savefig(fig_heatmap_quantiles_T1)
plot_heatmap(df, T2)
plt.savefig(fig_heatmap_quantiles_T2)

# for all ids
plot_heatmap(df1, T1)
plt.savefig(fig_heatmap_T1)
plot_heatmap(df2, T2)
plt.savefig(fig_heatmap_T2)

# create a dictionary to replace labels by string to show on map
cat_dict = {inc_cat[i]: inc_cat_names[i] for i in range(len(inc_cat))}
# (4) show ids on map color coded by income quantiles?
fig, ax = plt.subplots(figsize=(7, 5))
gdf.replace(cat_dict, inplace=True)
gdf.plot(
    column='category',
    categorical=True,
    cmap='RdBu',
    ax=ax,
    legend=True,
    legend_kwds={'bbox_to_anchor': (.2, 1.1), 'fontsize': 10, 'frameon': False})
ax.axis('off')
plt.tight_layout()
plt.savefig(fig_quantiles)

gdf = gdf.merge(df2, on='ID')


def plot_ranking_location(gdf, T):
    fs = 10
    # plot location on map of these areas
    fig, ax = plt.subplots(1, 2, figsize=(10, 6))

    ax0_divider = make_axes_locatable(ax[0])
    ax1_divider = make_axes_locatable(ax[1])

    cax0 = ax0_divider.append_axes("right", size="5%", pad="1%")
    cax1 = ax1_divider.append_axes("right", size="5%", pad="1%")

    print(gdf.crs)

    gdf.boundary.plot(ax=ax[0], color='black', lw=0.8)
    gdf.sort_values(by=[f'rank_asset_loss_T{T}'])[0:10].plot(
        column=f'rank_asset_loss_T{T}',
        ax=ax[0],
        cax=cax0,
        cmap='rocket',
        legend=True,
        legend_kwds={"label": "Top 10 priority areas"})

    gdf.boundary.plot(ax=ax[1], color='black', lw=0.8)
    gdf.sort_values(by=[f'rank_Ceq_loss_T{T}'])[0:10].plot(
        column=f'rank_Ceq_loss_T{T}',
        ax=ax[1],
        cax=cax1,
        cmap='rocket',
        legend=True,
        legend_kwds={"label": "Top 10 priority areas"})

    # add labels
    for x, y, label in zip(gdf.geometry.representative_point().x, gdf.geometry.representative_point().y,
                           gdf['ID']):
        ax[0].text(x, y, label, fontsize=fs, ha='right', va='bottom', color='white', fontweight='bold')

    for x, y, label in zip(gdf.geometry.representative_point().x, gdf.geometry.representative_point().y,
                           gdf['ID']):
        ax[1].text(x, y, label, fontsize=fs, ha='right', va='bottom', color='white', fontweight='bold')

    ax[0].title.set_text('Asset Losses')
    ax[1].title.set_text('Well-being Losses')

    ax[0].set_axis_off()
    ax[1].set_axis_off()

    plt.tight_layout()


plot_ranking_location(gdf, T1)
plt.savefig(fig_priorities_T1)
plot_ranking_location(gdf, T2)
plt.savefig(fig_priorities_T2)
plt.show()